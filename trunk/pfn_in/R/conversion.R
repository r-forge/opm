
################################################################################
#
# Conversion methods
#


#' Create portable file or directory names
#'
#' Rename files or directories to generate portable names. Names of directories
#' passed to this function cause them to be traversed recursively.
#'
#' @param paths Either character vector with names of files or directories, or
#'   data frame as generate by a previous call of this function.
#' @param lower Logical vector of length 1 that indicates whether file and
#'   directory names should also be converted to lowercase characters. Has only
#'   an effect if \code{paths} is a character vector.
#' @param enforce Numeric vector of length 1 that indicates under which
#'   circumstances renaming of files should be attempted. Has only an effect if
#'   \code{paths} is a data frame. Possible values are:
#'   \describe{
#'     \item{-1}{Do not rename anything, only conduct the checks.}
#'     \item{0}{Rename files unless the target is duplicated in the \sQuote{To}
#'     column of the \code{paths} data frame or already exists in the file
#'     system.}
#'     \item{1}{Rename files; overwrite existing files, if any, but take care of
#'     duplicates in the \sQuote{To} column of the \code{paths} data frame. That
#'     is, do not rename files if the target occurs a second time.}
#'     \item{2}{Rename files; overwrite existing files and overwrite duplicates
#'     in the \sQuote{To} column of the \code{paths} data frame, if any. This
#'     may cause loss of data and should only be applied if the lost files
#'     are superfluous.}
#'   }
#' @return Data frame with three columns \sQuote{From}, \sQuote{To} and
#'   \sQuote{Problem}, which contain character vectors.
#' @details When applied to a vector of path names this function does not
#'   actually rename anything but generates a data frame that indicates which
#'   files or directories should be renamed to what. This data frame can be
#'   inspected by the user prior to doing anything dangerous. Rows can be
#'   removed or set to a non-empty value in the \sQuote{Problem} column, which
#'   will cause them to be skipped when passed to the function again. Sorting
#'   the data frame in a different way is strongly discouraged, however.
#'
#'   When applied to a data frame as generated by a previous call of this
#'   function, it will conduct the renaming of files and directories as proposed
#'   in this data frame, subject to the conditions controlled by the
#'   \code{enforce} argument. The returned data frame will indicate in the
#'   \sQuote{Problem} column whether renaming was attempted and, if so, whether
#'   it was successful.
#'
#'   Here \sQuote{Portable Filename} is used as defined by the \emph{Open Group}
#'   (see \sQuote{References} section), i.e. only \acronym{ASCII} letters,
#'   numbers, period, hyphen-minus and underscore are permitted. To create
#'   portable but reasonably informative names, an attempt is made to replace
#'   non-Latin characters by their Latin counterparts and these by their
#'   \acronym{ASCII} counterparts. Some modifications from the \code{sanity.pl}
#'   script (see \sQuote{References} section) are also applied. All remaining
#'   special characters get removed by underscores. For further details see the
#'   code.
#' @note Renaming files or directories may fail for various reasons. See the
#'   documentation of \code{file.rename} for details.
#' @export
#' @family conversion-functions
#' @seealso base::file.rename
#' @keywords utilities
#' @references
#' \url{http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html}
#' @references
#' \url{https://en.wikipedia.org/wiki/ASCII}
#' @references
#' \url{https://github.com/splitbrain/sanity/blob/master/sanity.pl}
#' @examples
#' ## call 1: generate data frame but never rename
#' tasks <- sanitize()
#' head(tasks) # it may well be that nothing was found
#'
#' ## call 2: use data frame for renaming (if enforce >= 0)
#' result <- sanitize(paths = tasks, enforce = -1)
#' head(result) # additional problems may now be listed
#'
#' \dontrun{
#'
#'   ## immediately rename a single file
#'   sanitize(sanitize("mydir/file with spaces.txt"))
#'
#'   ## immediately rename two entire directories
#'   sanitize(sanitize(c("ugly directory", "../bad folder")))
#' }
#'
sanitize <- function(paths = getwd(), lower = FALSE, enforce = 0L) {

  if (is.data.frame(paths)) {

    stopifnot(is.character(paths[, "From"]), is.character(paths[, "To"]),
      !anyNA(paths), !anyDuplicated.default(paths[, "From"]),
      # an attempt to assess whether the original ordering is still present
      !is.unsorted(attr(paths, "row.names")), is.character(paths[, "Problem"]))
    if (!missing(enforce))
      stopifnot(is.numeric(enforce), length(enforce) == 1L)

    if (enforce < 2L) {
      ok <- !nzchar(paths[, "Problem"])
      e <- duplicated.default(paths[ok, "To"])
      if (any(e))
        paths[ok, "Problem"][e] <- "duplicate target"
    }

    if (enforce < 1L) {
      ok <- !nzchar(paths[, "Problem"])
      e <- file.exists(paths[ok, "To"])
      if (any(e))
        paths[ok, "Problem"][e] <- "target exists"
    }

    if (enforce < 0L) {
      NULL
    } else {
      ok <- !nzchar(paths[, "Problem"])
      e <- file.rename(paths[ok, "From"], paths[ok, "To"])
      if (any(e))
        paths[ok, "Problem"][e] <- "attempt failed"
    }

    return(paths)

  }

  # fixed-string replacements, usually one character to many characters
  REPLACEMENT <- c(
    # German umlauts
    "\xc3\xa4" = "ae",
    "\xc3\x84" = "AE",
    "\xc3\xb6" = "oe",
    "\xc3\x96" = "OE",
    "\xc3\xbc" = "ue",
    "\xc3\x9c" = "UE",
    # Scandinavian (1)
    "\xc3\x98" = "OE",
    "\xc3\xb8" = "oe",
    # German "scharf S"
    # "\xc3\x9f" = "ss",
    # "\xe1\xba\x9e" = "SS",
    # # Scandinavian (2)
    # "\xc3\xa6" = "ae",
    # "\xc3\x86" = "AE",
    # "\xc3\x90" = "D",
    # "\xc3\xb0" = "d",
    # # French
    # "\xc5\x93" = "oe",
    # "\xc5\x92" = "OE",
    # # Polish
    # "\xc5\x82" = "l",
    # "\xc5\x81" = "L",
    # # Turkish
    # "\xc4\xb1" = "i",
    # # dashes
    # "\xe2\x80\x92" = "-",
    # "\xe2\x80\x93" = "-",
    # "\xe2\x80\x94" = "-",
    # "\xe2\x80\x95" = "-"
    # from https://github.com/splitbrain/sanity/blob/master/sanity.pl
    "&" = "_and_",
    "@" = "_at_",
    # some additions; "big" supposed to mean "important"
    "?" = "_maybe_",
    "!" = "_big_",
    "*" = "_star_",
    "$" = "_dollar_",
    "%" = "_percent_",
    "+" = "_plus_",
    "#" = "_no_"
  )

  # Create portable file names. Try rescuing meaningful special characters.
  #
  new_name <- function(x, lower) {

    # rescue German umlauts etc. before removing accents
    for (from in names(REPLACEMENT))
      x <- gsub(from, REPLACEMENT[[from]], x, FALSE, FALSE, TRUE)

    # remove all accents (http://userguide.icu-project.org/transforms/general)
    # this is supposed to also correctly replace ligatures and German scharf-S
    # as well as French, Polish, Turkish and Scandinavian special characters,
    # among others; for exceptions see above
    x <- stri_trans_general(x, "Any-Latin; Latin-ASCII")

    # replace remaining disallowed characters by underscores
    x <- gsub("[^A-Za-z0-9._-]+", "_", x, FALSE, TRUE)

    # remove leading hyphens (possible confusion with command-line options),
    # leading periods and leading underscores; same for trailing characters
    x <- sub("^[._-]+", "", x, FALSE, TRUE)
    x <- sub("[._-]+$", "", x, FALSE, TRUE)

    # reduce runs of underscores to single underscore; same for periods
    # and hyphens
    x <- gsub("_{2,}", "_", x, FALSE, TRUE)
    x <- gsub("-{2,}", "-", x, FALSE, TRUE)
    x <- gsub("\\.{2,}", ".", x, FALSE, TRUE)

    # replace dashes and periods surrounded by underscores
    for (from in c("_-_", "-_", "_-"))
      x <- gsub(from, "-", x, FALSE, FALSE, TRUE)
    for (from in c("_._", "._", "_."))
      x <- gsub(from, ".", x, FALSE, FALSE, TRUE)

    if (lower)
      tolower(x)
    else
      x
  }

  remove_dot_dirs <- function(x) x[!is.element(x, c(".", ".."))]

  suggest_renaming <- function(path, lower) {
    path <- sort.int(path, NULL, NA, TRUE)
    base <- basename(path)
    rename <- !grepl("^[A-Za-z0-9._-]+$", base, FALSE, TRUE)
    structure(.Data = file.path(dirname(path[rename]),
      new_name(base[rename], lower)), .Names = path[rename])
  }

  paths <- sort.int(unique.default(normalizePath(paths)), NULL, NA, TRUE)
  isdir <- file.info(paths, extra_cols = FALSE)[, "isdir"]

  result <- c(
    suggest_renaming(paths[!isdir], lower),
    # here running list.files through lapply is faster than calling it directly
    lapply(lapply(X = paths[isdir], FUN = list.files, recursive = TRUE,
      full.names = TRUE, all.files = TRUE), suggest_renaming, lower),
    lapply(lapply(X = paths[isdir], FUN = list.dirs),
      suggest_renaming, lower),
    suggest_renaming(remove_dot_dirs(paths[isdir]), lower),
    recursive = TRUE
  )

  if (is.null(names(result))) # if the result is empty
    names(result) <- rep_len("", length(result))

  data.frame(From = names(result), To = unname(result),
    Problem = rep_len("", length(result)), stringsAsFactors = FALSE)

}


################################################################################
