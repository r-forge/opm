

################################################################################


#' Input \acronym{FAMES} objects from files
#'
#' Read data from \acronym{RTF} files output by the \acronym{MIDI} system and
#' convert them to \code{\link{FAMES}} object.
#'
#' @param names Character vector with names of files and/or directories. Passed
#'   to \code{explode_dir} from the \pkg{opm} package.
#' @param include Character scalar with wildcard (default) or regular-expression
#'   pattern for file selection (after expansion of directories) also passed to
#'   \code{explode_dir}.
#' @param ... Optional argument also passed to \code{explode_dir}. Most of them
#'   are for the fine-tuning of file selection and removal options.
#' @param demo Logical scalar indicating whether the final selection of files
#'   should not be tried to input but only their file names shown.
#' @return \code{\link{FAMES}} object, its length depending on the input size
#'   (number of input \acronym{MIDI} entries: a single one, several ones, or
#'   none).
#' @details The input of \acronym{RTF} files is \strong{not} guaranteed to work
#'   if these files have been opened with some word processing software and
#'   saved again after exporting them from the \acronym{MIDI} system. It makes
#'   even less sense to attempt to read other kinds of \acronym{RTF} files with
#'   this function.
#' @family io-functions
#' @keywords IO
#' @seealso opm::explode_dir
#' @export
#' @examples
#' ## show the files that would be read from the working directory
#' read_rtf(getwd(), demo = TRUE)
#'
#' (x <- read_rtf(character())) # no files/dirs => empty object
#' stopifnot(is(x, "FAMES"), length(x) == 0)
#'
#' ## read one of the example input files that come with the package
#' (files <- pkgutils::pkg_files("opmlipids", "testdata"))
#' if (length(files)) {
#'   (x <- read_rtf(files[1], include = NULL)) # pattern not necessary here
#'   stopifnot(is(x, "FAMES"), plate_type(x) == "MIDI", length(x) == 2)
#' } else {
#'   warning("'opmlipids' example input files not found")
#' }
#'
read_rtf <- function(names, include = "*.rtf", ..., demo = FALSE) {
  names <- explode_dir(names = names, include = include, ...)
  if (demo) {
    message(paste0(names, collapse = "\n"))
    return(invisible(names))
  }
  as(fatty_acids(files = names), FAMES)
}


################################################################################


#' Input MIDI fatty-acid objects
#'
#' These functions create objects suitable for storing fatty-acid information as
#' imported from \acronym{RTF} files generated by the \acronym{MIDI} system.
#'
#' @param x Character vector of lines read from a file in \acronym{RTF} format
#'   or according connection object. The \sQuote{flat_RTF} and \sQuote{RTF}
#'   methods are only for internal use. \code{x} can also be a list, but it is
#'   then expected to have the structure of either a \sQuote{midi_entry} or
#'   \sQuote{midi_entries} object. \code{x} can also be missing or
#'   \code{NULL}, but then a \code{files} argument is required.
#' @param level Numeric scalar indicating how far the conversion should go. A
#'   value of 4 or above yields the full parsing, creating a list of
#'   \sQuote{midi_entries} object. Lower values are for debugging only and
#'   yield intermediate results that are unlikely to be useful on the user and
#'   might change between distinct versions of the package.
#' @param delete Character vector with names of blocks to remove. The default
#'   values represent uninformative entries that should usually be removed.
#' @param files Vector of objects such as file names or conections that can be
#'   passed to \code{readLines} from the \pkg{base} package. This should yield
#'   character strings that can be parsed as \acronym{RTF}.
#' @param ... Optional arguments passed to and from other methods, or between
#'   the methods.
#' @return Under the default arguments, an object of class
#'   \sQuote{midi_entries}, which is a list of objects of the class
#'   \sQuote{midi_entry}. If the \code{level} argument is below 3, a list of
#'   lists is returned.
#' @keywords internal
#'
fatty_acids <- function(x, ...) {
  if (missing(x))
    UseMethod("fatty_acids", NULL)
  else
    UseMethod("fatty_acids", x)
}

#' @rdname fatty_acids
#' @method fatty_acids midi_entry
#' @export
#'
fatty_acids.midi_entry <- function(x, ...) {
  structure(.Data = list(x), class = "midi_entries")
}

#' @rdname fatty_acids
#' @method fatty_acids midi_entries
#' @export
#'
fatty_acids.midi_entries <- function(x, ...) {
  x
}

#' @rdname fatty_acids
#' @method fatty_acids list
#' @export
#'
fatty_acids.list <- function(x, ...) {
  as_fatty_acids <- function(x) {
    augment_table <- function(x) {
      pos <- grepl("^Summed\\s+Feature\\s+\\d+$", x[, "Peak Name"], TRUE, TRUE)
      x[, VALUE_COL] <- ifelse(pos, NA_real_, x[, "Percent"])
      pos <- !is.na(x[, VALUE_COL])
      if (any(pos)) { # completely empty tables are allowed at this step
        if (!isTRUE(all.equal(100, sum(x[pos, VALUE_COL]), TOLERANCE)))
          stop("relative frequencies do not sum up to 100%")
        rn <- ifelse(grepl("^Sum\\s*In\\s*Feature\\s*\\d+$", x[, "Peak Name"],
          TRUE, TRUE), x[, "Comment2"], x[, "Peak Name"])
        rownames(x)[pos] <- make.unique(norm_fa(rn[pos], TRUE), APPENDIX)
      }
      x
    }
    convert_table <- function(x) {
      if (is.data.frame(x))
        return(x)
      if (!is.list(x))
        stop("expected list or data frame, got ", class(x)[1L])
      data.frame(x, stringsAsFactors = FALSE, check.rows = TRUE,
        check.names = FALSE)
    }
    wanted <- c("Measurements", "Method", "Sample ID", "ID Number", "Type")
    if (length(bad <- which(is.na(match(wanted, names(x))))))
      stop(sprintf("entry '%s' is missing", wanted[bad[1L]]))
    x$Measurements <- augment_table(convert_table(x$Measurements))
    if (!is.na(i <- match("Matches", names(x))))
      x[[i]] <- convert_table(x[[i]])
    structure(.Data = x, class = "midi_entry")
  }
  x <- if (all(vapply(x, is.list, NA)))
    lapply(x, as_fatty_acids)
  else if (inherits(x, "midi_entry"))
    list(x)
  else
    list(as_fatty_acids(x))
  class(x) <- "midi_entries"
  x
}

#' @rdname fatty_acids
#' @method fatty_acids connection
#' @export
#'
fatty_acids.connection <- function(x, ...) {
  fatty_acids(readLines(con = x, warn = FALSE), ...)
}

#' @rdname fatty_acids
#' @method fatty_acids NULL
#' @export
#'
fatty_acids.NULL <- function(x, ..., files) {
  if (missing(files))
    stop("either an 'x' or a 'files' argument must be provided")
  if (!length(files))
    return(structure(list(), class = "midi_entries"))
  x <- lapply(files, readLines, warn = FALSE)
  x <- mapply(`attr<-`, x, ".file", files, SIMPLIFY = FALSE, USE.NAMES = FALSE)
  x <- lapply(X = x, FUN = fatty_acids.character, ...)
  case(length(x), structure(list(), class = "midi_entries"), x[[1L]],
    do.call(merge.midi_entries, x))
}

#' @rdname fatty_acids
#' @method fatty_acids character
#' @export
#'
fatty_acids.character <- function(x, ...) {
  fatty_acids.RTF(parse_rtf(x), ...)
}

#' @rdname fatty_acids
#' @method fatty_acids RTF
#' @export
#'
fatty_acids.RTF <- function(x, level = 4L,
    delete = c("fonttbl", "colortbl", "stylesheet", "*", "header", "footer",
      "pict", "pntxta", "pntxtb"), ...) {
  if (length(delete))
    x <- subset(x, delete)
  fatty_acids.flat_RTF(x = flatten(x), level = level, ...)
}

#' @rdname fatty_acids
#' @method fatty_acids flat_RTF
#' @export
#'
fatty_acids.flat_RTF <- function(x, level = 4L, ...) {

  trim_whitespace <- function(x) {
    sub("\\s+$", "", sub("^\\s+", "", x, FALSE, TRUE), FALSE, TRUE)
  }

  # Reduce non-table paragraphs to the informative content in a named character
  # vector.
  #
  simplify_nontable_paragraph <- function(x) {
    x <- paste0(x[!macro(x)], collapse = "\n")
    x <- strsplit(x, " {5,}|\n", FALSE, TRUE)
    x <- trim_whitespace(unlist(x, FALSE, FALSE))
    if (!length(x <- x[nzchar(x)]))
      return(character())
    x <- strsplit(x, "\\s*:\\s*", FALSE, TRUE)
    len <- vapply(x, length, 0L)
    x[pos] <- lapply(x[pos <- len == 1L], c, NA_character_)
    x[pos] <- lapply(x[pos <- len > 2L], function(y)
      c(y[1L], paste0(y[-1L], collapse = ":")))
    x <- do.call(rbind, x)
    structure(x[, 2L], names = x[, 1L])
  }

  # Table rows are located between \\trowd and \\trow, cell content is located
  # before \\cell. We assume there is only one table per paragraph.
  #
  simplify_table_paragraph <- function(x) {
    simplify_row <- function(x) trim_whitespace(ifelse(macro(x), "", x)[
      which(x == "\\cell") - 1L]) # add empty strings in place of empty cells
    x <- lapply(cut(x, breaks = c("trowd", "row")), simplify_row)
    must(do.call(rbind, x)) # zero-length rows disappear at this step
  }

  # Simplify elements of x, which is a list of RTF paragraphs, depending on
  # whether or not the element holds an RTF table.
  #
  simplify_paragraphs <- function(x) {
    is.table <- vapply(x, function(y) "\\trowd" %in% y[macro(y)], NA)
    x[is.table] <- lapply(x[is.table], simplify_table_paragraph)
    x[!is.table] <- lapply(x[!is.table], simplify_nontable_paragraph)
    x[vapply(x, length, 0L) > 0L]
  }

  # Convert MIDI matrix to data frame. Raise an error if non-numeric content is
  # encountered at unexpected positions.
  #
  parse_table <- function(x) {
    x[grepl("^-+$", x, perl = TRUE)] <- NA_character_
    headers <- x[1L, ]
    x <- as.data.frame(x[-1L, , drop = FALSE], stringsAsFactors = FALSE)
    names(x) <- headers
    rownames(x) <- NULL
    num.headers <- c("RT", "Response", "Ar/Ht", "RFact", "ECL", "Percent")
    name.headers <- c("Peak Name", "Comment1", "Comment2")
    if (setequal(headers, c("Library", "Sim Index", "Entry Name"))) {
      x[, "Sim Index"] <- must(as.numeric(x[, "Sim Index"]))
      attr(x, "kind") <- "Matches"
    } else if (setequal(headers, c(num.headers, name.headers))) {
      for (name in c(num.headers))
        x[, name] <- must(as.numeric(x[, name]))
      attr(x, "kind") <- "Measurements"
    } else
      stop("unknown set of table headers: ", paste0(headers, collapse = " / "))
    x
  }

  # Interpret elements of x, which is a list of simplified RTF paragraphs,
  # depending on whether or not the element is a matrix.
  #
  interpret_paragraphs <- function(x, filename) {
    tables <- lapply(x[is.mat <- vapply(x, is.matrix, NA)], parse_table)
    x <- unlist(lapply(x[!is.mat], as.list), recursive = FALSE)
    for (table in tables) {
      previous <- x[[kind <- attr(table, "kind")]]
      if (!is.null(previous) && !all(is.na(previous)))
        stop(kind, " entry already present")
      x[[kind]] <- structure(.Data = table, kind = NULL)
    }
    attr(x, ".file") <- filename
    class(x) <- c("midi_entry", oldClass(x))
    x
  }

  if (length(level <- as.integer(level)) != 1L || level < 0L)
    stop("'level' must be a non-negative integer scalar")
  if (is.null(filename <- attr(x, ".file")))
    warning("attribute '.file' is missing")
  x <- cut(x, breaks = "page")
  if (level < 1L)
    return(x)
  x <- lapply(x, FUN = cut, breaks = "par")
  if (level < 2L)
    return(x)
  x <- lapply(x, simplify_paragraphs)
  x <- x[vapply(x, length, 0L) > 0L]
  if (level < 3L)
    return(x)
  x <- lapply(x, interpret_paragraphs, filename)
  if (level < 4L)
    return(x)
  fatty_acids(x)
}


################################################################################


