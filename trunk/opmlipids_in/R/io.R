

################################################################################


#' Input \acronym{FAMES} objects from files
#'
#' Read data from \acronym{RTF} files output by the \acronym{MIDI} system and
#' convert them to \code{\link{FAMES}} object.
#'
#' @param names Character vector with names of files and/or directories. Passed
#'   to \code{explode_dir} from the \pkg{opm} package.
#' @param include Character scalar with wildcard (default) or regular-expression
#'   pattern for file selection (after expansion of directories) also passed to
#'   \code{explode_dir}.
#' @param ... Optional argument also passed to \code{explode_dir}. Most of them
#'   are for the fine-tuning of file selection and removal options.
#' @param demo Logical scalar indicating whether the final selection of files
#'   should not be tried to input but only their file names shown.
#' @return \code{\link{FAMES}} object, its length depending on the input size
#'   (number of input \acronym{MIDI} entries: a single one, several ones, or
#'   none).
#' @details The input of \acronym{RTF} files is \strong{not} guaranteed to work
#'   if these files have been opened with some word processing software and
#'   saved again after exporting them from the \acronym{MIDI} system. It makes
#'   even less sense to attempt to read other kinds of \acronym{RTF} files with
#'   this function.
#' @family io-functions
#' @keywords IO
#' @seealso opm::explode_dir
#' @export
#' @examples
#' ## show the files that would be read from the working directory
#' read_rtf(getwd(), demo = TRUE)
#'
#' (x <- read_rtf(character())) # no files/dirs => empty object
#' stopifnot(is(x, "FAMES"), length(x) == 0)
#'
#' ## read one of the example input files that come with the package
#' (files <- pkgutils::pkg_files("opmlipids", "testdata"))
#' if (length(files)) {
#'   (x <- read_rtf(files[1], include = NULL)) # pattern not necessary here
#'   stopifnot(is(x, "FAMES"), plate_type(x) == "MIDI", length(x) == 2)
#' } else {
#'   warning("'opmlipids' example input files not found")
#' }
#'
read_rtf <- function(names, include = "*.rtf", ..., demo = FALSE) {
  names <- explode_dir(names = names, include = include, ...)
  if (demo) {
    message(paste0(names, collapse = "\n"))
    return(invisible(names))
  }
  as(fatty_acids(files = names), "FAMES")
}


################################################################################


#' Input MIDI fatty-acid objects
#'
#' These functions create objects suitable for storing fatty-acid information as
#' imported from \acronym{RTF} files generated by the \acronym{MIDI} system.
#'
#' @param x Character vector of lines read from a file in \acronym{RTF} format
#'   or according connection object. The \sQuote{flat_RTF} and \sQuote{RTF}
#'   methods are only for internal use. \code{x} can also be a list, but it is
#'   then expected to have the structure of either a \sQuote{midi_entry} or
#'   \sQuote{midi_entries} object. \code{x} can also be missing or
#'   \code{NULL}, but then a \code{files} argument is required.
#' @param level Numeric scalar indicating how far the conversion should go. A
#'   value of 4 or above yields the full parsing, creating a list of
#'   \sQuote{midi_entries} object. Lower values are for debugging only and
#'   yield intermediate results that are unlikely to be useful on the user and
#'   might change between distinct versions of the package.
#' @param delete Character vector with names of blocks to remove. The default
#'   values represent uninformative entries that should usually be removed.
#' @param files Vector of objects such as file names or conections that can be
#'   passed to \code{readLines} from the \pkg{base} package. This should yield
#'   character strings that can be parsed as \acronym{RTF}.
#' @param ... Optional arguments passed to and from other methods, or between
#'   the methods.
#' @return Under the default arguments, an object of class
#'   \sQuote{midi_entries}, which is a list of objects of the class
#'   \sQuote{midi_entry}. If the \code{level} argument is below 3, a list of
#'   lists is returned.
#' @keywords internal
#'
fatty_acids <- function(x, ...) {
  if (missing(x))
    UseMethod("fatty_acids", NULL)
  else
    UseMethod("fatty_acids", x)
}

#' @rdname fatty_acids
#' @method fatty_acids midi_entry
#' @export
#'
fatty_acids.midi_entry <- function(x, ...) {
  structure(.Data = list(x), class = "midi_entries")
}

#' @rdname fatty_acids
#' @method fatty_acids midi_entries
#' @export
#'
fatty_acids.midi_entries <- function(x, ...) {
  x
}

#' @rdname fatty_acids
#' @method fatty_acids list
#' @export
#'
fatty_acids.list <- function(x, ...) {
  as_fatty_acids <- function(x) {
    augment_table <- function(x) {
      pos <- grepl("^\\s*Summed\\s+Feature\\s+\\d+\\s*$", x[, "Peak Name"],
        TRUE, TRUE)
      value.col <- get_for("MIDI", "value.col")
      x[, value.col] <- ifelse(pos, NA_real_, x[, "Percent"])
      if (any(pos <- !is.na(x[, value.col]))) {
        rn <- ifelse(grepl("^\\s*Sum\\s*In\\s*Feature\\s*\\d+\\s*$",
          x[, "Peak Name"], TRUE, TRUE), x[, "Comment2"], x[, "Peak Name"])
        rownames(x)[pos] <- make.unique(norm_fa(rn[pos], TRUE), APPENDIX)
      }
      x
    }
    convert_table <- function(x) {
      if (is.data.frame(x))
        return(x)
      if (!is.list(x))
        stop("expected list or data frame, got ", class(x)[1L])
      data.frame(x, stringsAsFactors = FALSE, check.rows = TRUE,
        check.names = FALSE)
    }
    wanted <- c("Measurements", "Method", "Sample ID", "ID Number", "Type")
    if (length(bad <- which(is.na(match(wanted, names(x))))))
      stop(sprintf("entry '%s' is missing", wanted[bad[1L]]))
    x$Measurements <- augment_table(convert_table(x$Measurements))
    if (!is.na(i <- match("Matches", names(x))))
      x[[i]] <- convert_table(x[[i]])
    structure(.Data = x, class = "midi_entry")
  }
  x <- if (all(vapply(x, is.list, NA)))
    lapply(x, as_fatty_acids)
  else if (inherits(x, "midi_entry"))
    list(x)
  else
    list(as_fatty_acids(x))
  class(x) <- "midi_entries"
  x
}

#' @rdname fatty_acids
#' @method fatty_acids connection
#' @export
#'
fatty_acids.connection <- function(x, ...) {
  fatty_acids(readLines(con = x, warn = FALSE), ...)
}

#' @rdname fatty_acids
#' @method fatty_acids NULL
#' @export
#'
fatty_acids.NULL <- function(x, ..., files) {
  if (missing(files))
    stop("either an 'x' or a 'files' argument must be provided")
  if (!length(files))
    return(structure(list(), class = "midi_entries"))
  x <- lapply(files, readLines, warn = FALSE)
  x <- mapply(`attr<-`, x, ".file", files, SIMPLIFY = FALSE, USE.NAMES = FALSE)
  x <- lapply(X = x, FUN = fatty_acids.character, ...)
  case(length(x), structure(list(), class = "midi_entries"), x[[1L]],
    do.call(merge.midi_entries, x))
}

#' @rdname fatty_acids
#' @method fatty_acids character
#' @export
#'
fatty_acids.character <- function(x, ...) {
  fatty_acids.RTF(parse_rtf(x), ...)
}

#' @rdname fatty_acids
#' @method fatty_acids RTF
#' @export
#'
fatty_acids.RTF <- function(x, level = 4L,
    delete = c("fonttbl", "colortbl", "stylesheet", "*", "header", "footer",
      "pict", "pntxta", "pntxtb"), ...) {
  if (length(delete))
    x <- subset(x, delete)
  fatty_acids.flat_RTF(x = flatten(x), level = level, ...)
}

#' @rdname fatty_acids
#' @method fatty_acids flat_RTF
#' @export
#'
fatty_acids.flat_RTF <- function(x, level = 4L, ...) {

  trim_whitespace <- function(x) {
    sub("\\s+$", "", sub("^\\s+", "", x, FALSE, TRUE), FALSE, TRUE)
  }

  # Reduce non-table paragraphs to the informative content in a named character
  # vector.
  #
  simplify_nontable_paragraph <- function(x) {
    x <- paste0(x[!macro(x)], collapse = "\n")
    x <- strsplit(x, " {5,}|\n", FALSE, TRUE)
    x <- trim_whitespace(unlist(x, FALSE, FALSE))
    if (!length(x <- x[nzchar(x)]))
      return(character())
    x <- strsplit(x, "\\s*:\\s*", FALSE, TRUE)
    len <- vapply(x, length, 0L)
    x[pos] <- lapply(x[pos <- len == 1L], c, NA_character_)
    x[pos] <- lapply(x[pos <- len > 2L], function(y)
      c(y[1L], paste0(y[-1L], collapse = ":")))
    x <- do.call(rbind, x)
    structure(x[, 2L], names = x[, 1L])
  }

  # Table rows are located between \\trowd and \\trow, cell content is located
  # before \\cell. We assume there is only one table per paragraph.
  #
  simplify_table_paragraph <- function(x) {
    simplify_row <- function(x) trim_whitespace(ifelse(macro(x), "", x)[
      which(x == "\\cell") - 1L]) # add empty strings in place of empty cells
    x <- lapply(cut(x, breaks = c("trowd", "row")), simplify_row)
    must(do.call(rbind, x)) # zero-length rows disappear at this step
  }

  # Simplify elements of x, which is a list of RTF paragraphs, depending on
  # whether or not the element holds an RTF table.
  #
  simplify_paragraphs <- function(x) {
    is.table <- vapply(x, function(y) "\\trowd" %in% y[macro(y)], NA)
    x[is.table] <- lapply(x[is.table], simplify_table_paragraph)
    x[!is.table] <- lapply(x[!is.table], simplify_nontable_paragraph)
    x[vapply(x, length, 0L) > 0L]
  }

  # Convert MIDI matrix to data frame. Raise an error if non-numeric content is
  # encountered at unexpected positions.
  #
  parse_table <- function(x) {
    x[grepl("^-+$", x, perl = TRUE)] <- NA_character_
    headers <- x[1L, ]
    x <- as.data.frame(x[-1L, , drop = FALSE], stringsAsFactors = FALSE)
    names(x) <- headers
    rownames(x) <- NULL
    num.headers <- c("RT", "Response", "Ar/Ht", "RFact", "ECL", "Percent")
    name.headers <- c("Peak Name", "Comment1", "Comment2")
    if (setequal(headers, c("Library", "Sim Index", "Entry Name"))) {
      x[, "Sim Index"] <- must(as.numeric(x[, "Sim Index"]))
      attr(x, "kind") <- "Matches"
    } else if (setequal(headers, c(num.headers, name.headers))) {
      for (name in c(num.headers))
        x[, name] <- must(as.numeric(x[, name]))
      attr(x, "kind") <- "Measurements"
    } else
      stop("unknown set of table headers: ", paste0(headers, collapse = " / "))
    x
  }

  # Interpret elements of x, which is a list of simplified RTF paragraphs,
  # depending on whether or not the element is a matrix.
  #
  interpret_paragraphs <- function(x, filename) {
    tables <- lapply(x[is.mat <- vapply(x, is.matrix, NA)], parse_table)
    x <- unlist(lapply(x[!is.mat], as.list), recursive = FALSE)
    for (table in tables) {
      previous <- x[[kind <- attr(table, "kind")]]
      if (!is.null(previous) && !all(is.na(previous)))
        stop(kind, " entry already present")
      x[[kind]] <- structure(.Data = table, kind = NULL)
    }
    attr(x, ".file") <- filename
    class(x) <- c("midi_entry", oldClass(x))
    x
  }

  if (length(level <- as.integer(level)) != 1L || level < 0L)
    stop("'level' must be a non-negative integer scalar")
  if (is.null(filename <- attr(x, ".file")))
    warning("attribute '.file' is missing")
  x <- cut(x, breaks = "page")
  if (level < 1L)
    return(x)
  x <- lapply(x, FUN = cut, breaks = "par")
  if (level < 2L)
    return(x)
  x <- lapply(x, simplify_paragraphs)
  x <- x[vapply(x, length, 0L) > 0L]
  if (level < 3L)
    return(x)
  x <- lapply(x, interpret_paragraphs, filename)
  if (level < 4L)
    return(x)
  fatty_acids(x)
}


################################################################################


#' Parse \acronym{RTF}
#'
#' A simple \acronym{RTF} parser. It removes delimiters from the control words
#' and outcomments percent characters. Afterwards the text is parsed with
#' \code{parseLatex} from the \pkg{tools} package, and an \sQuote{RTF} object is
#' returned (which has \sQuote{LaTeX} as parent class).
#'
#' @param x Character vector.
#' @return Object of class \sQuote{RTF}.
#' @keywords internal
#' @note The way the input is currently parsed implies that \acronym{RTF} files
#'   cannot be regenerated from such objects, and the function is only good for
#'   reading from \acronym{RTF} content, but neither for reading from
#'   \acronym{RTF} format entries nor for manipulating and generating novel
#'   \acronym{RTF}.
#' @seealso tools::parseLatex
#'
parse_rtf <- function(x) UseMethod("parse_rtf")

#' @rdname parse_rtf
#' @method parse_rtf character
#'
parse_rtf.character <- function(x) {
  if (is.null(fromfile <- attr(x, ".file")))
    warning("attribute '.file' is missing")
  x <- gsub("(\\\\[a-z]+)-?\\d+", "\\1", x, FALSE, TRUE)
  x <- parseLatex(gsub("%", "\\%", x, FALSE, FALSE, TRUE))
  class(x) <- c("RTF", oldClass(x))
  attr(x, ".file") <- fromfile
  x
}


################################################################################


#' Internal conversion functions for \acronym{MIDI} data
#'
#' Split an object of class \sQuote{flat_RTF} into sections, or create such an
#' object from an object of class \code{RTF}. Alternatively, create a subset of
#' a \sQuote{midi_entries} object or merge several such objects (or objects that
#' are convertible to such objects) into a single one.
#'
#' @param object Object of class \sQuote{RTF}.
#' @param x Object of class \sQuote{flat_RTF}, \sQuote{RTF} or
#'   \sQuote{midi_entries}. For the \code{merge} method, optionally a
#'   \sQuote{midi_entry} object.
#' @param y Object convertible via \code{\link{fatty_acids}}.
#' @param breaks Character vector. A backslash is prepended if necessary.
#' @param delete Optional character vector determining which
#'   \sQuote{midi_entry} objects to remove from a \sQuote{midi_entries}
#'   object.
#' @param ... Optional arguments. For the \code{merge} methods, other objects
#'   like \code{y}.
#' @return Object of class \sQuote{flat_RTF} or list of such objects, or object
#'   of class \sQuote{midi_entries}.
#' @details The \sQuote{midi_entries} currently supports the following
#'   \code{delete} entries (several ones can be given): \describe{
#'   \item{calib}{Remove those \sQuote{midi_entry} object with \sQuote{Type}
#'   set to \sQuote{Calib}. These are calibration runs that contain no sample
#'   data.} }
#'
#'   For the \sQuote{midi_entries} method of \code{merge} it is an error if
#'   a \sQuote{Method} entry is lacking, and a warning is issued if these
#'   entries are not uniform.
#' @name cut
#' @keywords internal
#'
NULL

#' @rdname cut
#' @method cut flat_RTF
#' @export
#'
cut.flat_RTF <- function(x, breaks, ...) {
  if (!length(breaks))
    stop("'breaks' must not be empty")
  breaks <- sections(x %in% to_macro(breaks) & macro(x), include = FALSE)
  mapply(structure, .Data = split(x, breaks), macro = split(macro(x), breaks),
    MoreArgs = list(class = oldClass(x), .file = attr(x, ".file")),
    SIMPLIFY = FALSE, USE.NAMES = FALSE)
}

#' @rdname cut
#' @method flatten RTF
#' @export
#'
flatten.RTF <- function(object, ...) {
  file <- attr(object, ".file")
  tags <- rapply(object, attr, which = "latex_tag")
  object <- unlist(object, TRUE, FALSE)
  if (length(tags) != length(object))
    stop("malformatted RTF object: not as many tags as elements")
  if (length(bad <- setdiff(tags, c("MACRO", "TEXT"))))
    stop("malformatted RTF object: unknown tag ", bad[1L])
  structure(object, macro = tags == "MACRO", class = "flat_RTF", .file = file)
}

#' @rdname cut
#' @method subset midi_entries
#' @export
#'
subset.midi_entries <- function(x, delete = "calib", ...) {
  delete <- match.arg(delete, several.ok = TRUE)
  if ("calib" %in% delete)
    x[vapply(x, `[[`, "", i = "Type") == "Calib"] <- NULL
  x
}

#' @rdname cut
#' @method subset RTF
#' @export
#'
subset.RTF <- function(x, delete, ...) {
  # Newer version, but since flatten() has been improved this is currently the
  # limiting step. Perhaps this can be omitted and replaced by deleting stuff
  # after splitting into paragraphs? But the usual blocks to delete do not
  # necessarily occur at a given level.
  must_delete <- function(x) is.character(x[[1L]]) && any(x[[1L]] %in% delete)
  delete_recursively <- function(x) {
    bad <- is.block <- vapply(x, is.list, NA)
    bad[bad] <- vapply(x[bad], must_delete, NA)
    x[is.block] <- lapply(x[is.block <- is.block & !bad], delete_recursively)
    x[bad] <- NULL
    x
  }
  if (!missing(delete) && length(delete <- to_macro(delete)))
    x <- delete_recursively(x)
  x
}

#' @rdname cut
#' @method merge midi_entry
#' @export
#'
merge.midi_entry <- function(x, y, ...) {
  # convert x to 'midi_entries' object, then move on
  merge(x = fatty_acids(x), y = y, ...)
}

#' @rdname cut
#' @method merge midi_entries
#' @export
#'
merge.midi_entries <- function(x, y, ...) {
  y <- unlist(lapply(list(y, ...), FUN = fatty_acids), recursive = FALSE)
  methods <- vapply(x, `[[`, "", i = "Method")
  if (!all(duplicated.default(methods)[-1L]))
    warning("non-uniform 'Method' entries")
  structure(c(x, y), class = oldClass(x))
}


################################################################################


