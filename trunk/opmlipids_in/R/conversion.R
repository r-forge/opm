

################################################################################


#' Extract values and metadata or export phylogenetic data
#'
#' Extract selected values into common matrix or data frame with or without
#' metadata, or generate a file format suitable for exporting phylogenetic data.
#' This function can also produce \acronym{HTML} tables and text paragraphs
#' suitable for displaying fatty-acid data in taxonomic journals such as
#' \acronym{IJSEM}.
#'
#' @param object \code{\link{FAMES}}. For \code{phylo_data}, alternatively a
#'   \code{FAMES_Listing} object.
#' @param as.labels List, character vector or formula indicating the metadata to
#'   be joined and used as row names (if \code{dataframe} is \code{FALSE}) or
#'   additional columns (if otherwise). Ignored if \code{NULL}. See the
#'   \pkg{opm} package for further details on this \code{extract} argument.
#' @param dataframe Logical scalar. Return data frame or matrix?
#'
#' @param as.groups For the \code{\link{FAMES}} method, a list, character vector
#'   or formula indicating the metadata to be joined and either used as
#'   \sQuote{row.groups} attribute of the output matrix or as additional columns
#'   of the output data frame. See \code{\link{heat_map}} for its usage. Ignored
#'   if empty.
#'
#'   If a \code{as.groups} is a formula and \code{dataframe} is \code{TRUE}, the
#'   pseudo-function \code{J} within the formula can be used to trigger
#'   combination of factors immediately after selecting them as data-frame
#'   columns, much like \code{as.labels}.
#'
#'   If \code{as.groups} is a logical scalar, \code{TRUE} yields a trivial group
#'   that contains all elements, \code{FALSE} yields one group per element, and
#'   \code{NA} yields an error. The column name in which this factor is placed
#'   if \code{dataframe} is \code{TRUE} is determined using
#'   \code{opm_opt("group.name")}.
#' @param sep Character scalar. Used as separator between the distinct metadata
#'   entries if these are to be pasted together.
#' @param dups Character scalar specifying what to do in the case of duplicate
#'   labels: either \sQuote{warn}, \sQuote{error} or \sQuote{ignore}. Ignored
#'   unless \code{join} is \code{TRUE} and if \code{object} is an
#'   \code{\link{OPM}} object. For the data-frame method of \code{extract}, a
#'   character scalar defining the action to conduct if \code{as.groups}
#'   contains duplicates.
#' @param exact Logical scalar. Passed to \code{\link{metadata}}.
#' @param strict Logical scalar. Also passed to \code{\link{metadata}}.
#' @param join Logical scalar or factor. Passed to the matrix method of
#'   \code{phylo_data}. See the \pkg{opm} package for details and the examples
#'   below.
#' @param format Character scalar also passed to that methods. Determines the
#'   output format. For continuous data such as proportion measurements only
#'   \kbd{html} and \kbd{hennig} are suitable.
#' @param digits Integer scalar determining the number of decimal places in the
#'   output.
#' @param html.args List determining details of the \acronym{HTML} output. See
#'   \code{html_args} in the \pkg{opm} package. Slight modifications of the
#'   settings are done internally.
#' @param run.tidy Logical scalar passed to the parent method.
#' @param ... Optional arguments passed to the matrix method of
#'   \code{phylo_data}.
#'
#' @export
#' @aliases phylo_data
#' @return Numeric matrix or data frame (\code{extract}) or character vector
#'   (\code{phylo_data}).
#' @details Two kinds of \acronym{HTML} can be generated for comparing
#'   measurements between metadata-defined groups. Either a table is generated
#'   by applying \code{phylo_data} directly to a \code{\link{FAMES}} object, or
#'   \acronym{HTML}-formatted text is generated by calling \code{\link{listing}}
#'   in the first step and \code{phylo_data} in the second step.
#'
#' @family conversion-functions
#' @seealso
#'   base::data.frame base::as.data.frame base::as.matrix base::cbind
#' @keywords manip character cluster IO
#' @examples
#'
#' ## introduce useful metadata entries
#' x <- DSM_44549
#' metadata(x) <- Strain ~ sub("C-", "-", sub("[(].+", "", `Sample ID`))
#' metadata(x) <- Time ~ tolower(substr(sub("[^(]+[(]", "", `Sample ID`), 1, 3))
#' metadata(x) <- Cultivation ~ sub("[)]", "", sub("[^,]+,", "", `Sample ID`))
#'
#' ## extract data frame
#' (y <- extract(x, list("Strain", "Time"), TRUE, "Cultivation"))
#' stopifnot(is.data.frame(y), c("Strain", "Time") %in% names(y))
#' stopifnot(c("Cultivation", opm::param_names("split.at")) %in% names(y))
#' # note positioning of separator column
#'
#' ## extract matrix
#' (y <- extract(x, list("Strain", "Time"), FALSE, "Cultivation",
#'   dups = "ignore"))
#' stopifnot(is.matrix(y), is.numeric(y))
#' stopifnot(!c("Strain", "Time") %in% names(y))
#' stopifnot(!c("Cultivation", opm::param_names("split.at")) %in% names(y))
#' # i.e. the selected metadata are not inserted as columns but elsewhere
#' # see opm for details
#'
#' ## create HTML
#' write(y <- phylo_data(x, "Cultivation", format = "html",
#'   html.args = html_args(organisms.start = "Cultivation:",
#'     legend.sep.2 = "; ", css.file = opm_files("css")[1])), file = "")
#' stopifnot(is.character(y), "<html>" %in% y)
#'
#' ## compare two strains in HTML table
#' x <- c(DSM_44549, DSM_7109)
#' metadata(x) <- Strain ~ sub("C-", "-", sub("[(].+", "", `Sample ID`))
#' write(y <- phylo_data(x, "Strain", format = "html",
#'   html.args = html_args(legend.sep.2 = "; ",
#'     css.file = opm_files("css")[1])), file = "")
#' stopifnot(is.character(y), "<html>" %in% y)
#'
setGeneric("extract", function(object, ...) standardGeneric("extract"))

setMethod("extract", "FAMES", function(object, as.labels, dataframe = FALSE,
    as.groups = NULL, sep = " ", dups = "warn", exact = TRUE, strict = TRUE) {

  do_extract <- function(what, join, dups) {
    extract_columns(object, what = what, join = join, sep = sep, dups = dups,
      exact = exact, strict = strict)
  }

  create_groups <- function(x, join) {
    result <- do_extract(x, join, "ignore")
    if (join)
      as.factor(result)
    else
      result
  }

  result <- as(object, "matrix")

  if (dataframe) {

    result <- as.data.frame(result)
    if (length(as.labels)) {
      columns <- do_extract(as.labels, FALSE, "ignore")
      columns <- cbind(columns, plate_type(object))
      colnames(columns)[ncol(columns)] <- param_names("split.at")
      rownames(result) <- rownames(columns) # otherwise a warning is likely
      result <- cbind(columns, result)
    } else {
      params <- rownames(result)
      rownames(result) <- seq_len(nrow(result))
      result <- cbind(params, result)
      colnames(result)[1L] <- param_names("split.at")
    }
    if (length(as.groups))
      result <- cbind(result, create_groups(as.groups, FALSE))

  } else {

    if (length(as.labels)) {
      labels <- do_extract(as.labels, TRUE, dups)
      rownames(result) <- labels
    } else {
      rownames(result) <- seq_len(nrow(result))
    }
    if (length(as.groups))
      attr(result, "row.groups") <- create_groups(as.groups, TRUE)
  }

  result

}, sealed = SEALED)

#= phylo_data extract

setMethod("phylo_data", "FAMES", function(object, as.labels, sep = " ",
    exact = TRUE, strict = TRUE, join = TRUE, format = "html",
    html.args = html_args(), digits = 1L, ...) {
  object <- extract(object = object, as.labels = as.labels, dataframe = FALSE,
    as.groups = NULL, sep = sep, dups = if (is.logical(join) && join)
      "ignore"
    else
      "warn", exact = exact, strict = strict)
  if ("html" %in% format) {
    if (!is.list(html.args))
      html.args <- as.list(html.args)
    html.args$greek.letters <- html.args$no.html <- FALSE
    object <- object[, order(colSums(object), decreasing = TRUE), drop = FALSE]
    colnames(object) <- fs_to_html(colnames(object))
  }
  phylo_data(object = object, join = join, format = format,
    html.args = html.args, digits = digits, ...)
}, sealed = SEALED)

setOldClass("FAMES_Listing")

setMethod("phylo_data", "FAMES_Listing", function(object,
    html.args = html_args(), run.tidy = FALSE) {
  if (!attr(object, "html"))
    return(paste(object, collapse = " "))
  if (!is.list(html.args))
    html.args <- as.list(html.args)
  html.args$greek.letters <- html.args$no.html <- FALSE
  class(object) <- oldClass(object)[-1L]
  phylo_data(object = object, html.args = html.args, run.tidy = run.tidy)
}, sealed = SEALED)


################################################################################


#' Update the measurements
#'
#' Update the \code{\link{measurements}} stored within a \code{\link{FAME}} or
#' \code{\link{FAME}} object.
#'
#' @param object \code{\link{FAMES}} or \code{\link{FAME}} object or object
#'   suitable for the \code{\link{measurements}} entry of a \code{\link{FAME}}
#'   object.
#' @param unnamed Logical scalar indicating whether unnamed fatty acids, if any,
#'   should be named and the percentages accordingly recalculated.
#' @param ... Optional parameters passed between the methods.
#' @return Object of the same class as \code{object}.
#' @note For manipulating the metadata, see the methods for \code{WMDS} and
#'   \code{WMDS} objects described in the \pkg{opm} manual.
#' @export
#' @keywords attribute character
#' @family conversion-functions
#' @examples
#' (x <- update(DSM_7109))
#' stopifnot(!identical(DSM_7109, x))
#'
setGeneric("update")

setMethod("update", "FAMES", function(object, ...) {
  for (i in seq_along(object@plates))
    object@plates[[i]] <- update(object@plates[[i]], ...)
  object
}, sealed = SEALED)

setMethod("update", "FAME", function(object, ...) {
  object@measurements <- update(object@measurements, ...)
  object
}, sealed = SEALED)

setMethod("update", "MIDI", function(object, unnamed = TRUE, ...) {
  recalculate_percents <- function(x, klass) {
    interpolate_rfact <- function(x) {
      if (any(x[, "Interpol"] <- is.na(x[, "RFact"]) & !is.na(x[, "RT"]))) {
        m <- lm(log(x[, "RFact"]) ~ log(x[, "RT"]))
        x[, "RFact"] <- ifelse(x[, "Interpol"], exp(predict(m, x)),
          x[, "RFact"])
      }
      x
    }
    x <- interpolate_rfact(x)
    skip <- grepl("^(<\\s+min|>\\s+max)\\s+rt$", x[, "Comment1"], TRUE, TRUE) |
      grepl("^Summed\\s+Feature\\s+\\d+$", x[, "Peak Name"], TRUE, TRUE)
    val <- ifelse(skip, NA_real_, x[, "Response"] * x[, "RFact"])
    val <- 100 * val / sum(val, na.rm = TRUE)
    val.col <- get_for(str_head(klass), "value.col")
    is.nn <- is.na(x[, val.col]) & !is.na(val)
    x[, val.col] <- val
    nn <- ifelse(nzchar(x[, "Peak Name"]), x[, "Peak Name"],
      sprintf("unknown %0.2f", x[, "ECL"]))
    nn[is.nn] <- norm_fa(nn[is.nn], TRUE)
    rownames(x) <- make.unique(ifelse(is.nn, nn, rownames(x)), APPENDIX)
    x
  }
  klass <- class(object)
  object <- data.frame(object, check.names = FALSE)
  if (unnamed)
    object <- recalculate_percents(object, klass)
  new(klass, object)
}, sealed = SEALED)


################################################################################

