

################################################################################


#' Files, parameter names and colour sets used by the package
#'
#' Get list of files from the \pkg{opm} package of interest for the user, or
#' get list of predefined parameter names of interest for the user, or select
#' from some predefined colour sets for plotting.
#'
#' @param what Character scalar indicating the subdirectory to search in or
#'   the kind of names to obtain. Currently the following subdirectories are
#'   included:
#'   \describe{
#'     \item{auxiliary}{Miscellaneous files which are neither executable
#'       scripts nor test data.}
#'     \item{css}{Predefined \acronym{CSS} files for \acronym{HTML} files
#'     generated by, e.g., \code{\link{phylo_data}}.}
#'     \item{doc}{The vignette (documentation) in several formats, including
#'       the extracted \R code.}
#'     \item{demo}{Example \R code using the \pkg{opm} package that neither
#'       fitted into these help pages nor into the vignette. Can directly be
#'       loaded via \code{demo}; see \code{demo(package = "opm")}.}
#'     \item{growth}{Growth-measurement example files.}
#'     \item{multiple}{Not directly readable (i.e., multiple-plate) test files.}
#'     \item{omnilog}{Directly readable (i.e., single-plate) test files from
#'       OmniLog\eqn{\textsuperscript{\textregistered}}{(R)} runs.}
#'     \item{scripts}{\R script files for non-interactive uses of the
#'       \pkg{opm} package, particularly for the batch processing of many files.
#'       When called without input arguments or with the \sQuote{-h} switch, the
#'       scripts output usage information.}
#'     \item{single}{Directly readable (i.e., single-plate) test files.}
#'     \item{sql}{\acronym{SQL} files for working with relational databases.}
#'     \item{testdata}{Files as output by the devices such as the
#'       OmniLog\eqn{\textsuperscript{\textregistered}}{(R)} instrument.
#'       Included here as examples for data input (and metadata management).}
#'   }
#'   and the following kinds of parameter names:
#'   \describe{
#'     \item{param.names}{Names of the estimated curve parameters used
#'     internally and in the output.}
#'     \item{disc.name}{Alternative name used to select discretised values
#'       instead.}
#'     \item{reserved.md.names}{Names that should not be used in metadata
#'     entries because they are used as predefined column names by functions
#'     such as \code{\link{flatten}}.}
#'     \item{split.at}{The name of the column in data frames generated by
#'     \code{\link{extract}} that separates data from metadata.}
#'   }
#' @param set Character scalar. Name of the colour vector to use. Colour vectors
#'   have been optimised for maximum contrast between adjacent colours, either
#'   manually or using \code{max_rgb_contrast} from the \pkg{pkgutils} package.
#'   Names ending in \sQuote{.i} indicate vectors in inverse order (compared to
#'   the vector with the same name except \sQuote{.i}).
#' @export
#' @return Character vector of file names or reserved parameter names or names
#'   of colours.
#' @details
#'   In addition to the results of \sQuote{reserved.md.names}, it should be
#'   avoided to use metadata keys that start with a dot, as such keys might also
#'   be created intermediary by methods that have to compile metadata together
#'   with other information.
#'
#'   Note that \code{pkg_files} might fail with very unusual installations of
#'   the \pkg{opm} package.
#'
#'   See \code{\link{xy_plot}} for a usage example of \code{select_colors}. This
#'   function  is not normally directly called by an \pkg{opm} user but could be
#'   used for testing before doing some serious plotting.
#'
#' @family naming-functions
#' @seealso pkgutils::pkg_files utils::demo
#'   grDevices::colors grDevices::rainbow grDevices::grey
#' @keywords utilities color
#' @references \url{http://www.colorbrewer.org}
#' @examples
#' ## example input files
#' isRfile <- function(x) grepl("\\.R$", x, ignore.case = TRUE)
#' (x <- opm_files("auxiliary"))
#' stopifnot(!isRfile(x))
#' (x <- opm_files("demo"))
#' stopifnot(isRfile(x))
#' (x <- opm_files("scripts"))
#' stopifnot(isRfile(x))
#' (x <- opm_files("testdata"))
#' stopifnot(!isRfile(x))
#' for (name in c("growth", "single", "multiple", "omnilog")) {
#'   print(y <- opm_files(name))
#'   stopifnot(y %in% x) # i.e., a subset of the set of all input example files
#' }
#'
#' # On UNIX systems you should be able to do this if Rscript and the optparse
#' # package are properly installed:
#' # invisible(sapply(paste("Rscript", opm_files()), system))
#' # ...and get the usage messages of all scripts.
#'
#' ## reserved parameter names
#' (x <- param_names())
#' stopifnot(is.character(x), length(x) > 1, identical(unique(x), x))
#' (x <- param_names("reserved"))
#' stopifnot(is.character(x), length(x) > 1, identical(unique(x), x))
#' stopifnot(param_names("split.at") %in% x)
#'
#' ## colours
#' (x <- select_colors("nora"))
#' (y <- select_colors("nora.i")) # same in reverse order
#' stopifnot(is.character(x), length(x) > 0L, identical(x, rev(y)))
#'
opm_files <- function(what = c("scripts", "testdata", "auxiliary", "demo",
    "doc", "css", "sql", "omnilog", "single", "multiple", "growth")) {
  switch(what <- match.arg(what),
    css = grep("\\.css$", pkg_files(opm_string(), "auxiliary"),
      TRUE, TRUE, TRUE),
    growth = grep("\\.asc(\\.[^.]+)?$",
      pkg_files(opm_string(), "testdata"), TRUE, TRUE, TRUE),
    multiple = grep("Multiple\\.csv(\\.[^.]+)?$",
      pkg_files(opm_string(), "testdata"), TRUE, TRUE, TRUE),
    omnilog = grep("Example(_Old_Style)?_\\d+\\.csv(\\.[^.]+)?$",
      pkg_files(opm_string(), "testdata"), TRUE, TRUE, TRUE),
    single = grep("Multiple\\.csv(\\.[^.]+)?$", pkg_files(opm_string(),
      "testdata"), TRUE, TRUE, TRUE, FALSE, FALSE, TRUE),
    sql = grep("\\.sql$", pkg_files(opm_string(), "auxiliary"),
      TRUE, TRUE, TRUE),
    pkg_files(opm_string(), what)
  )
}

#' @rdname opm_files
#' @export
#'
param_names <- function(
    what = c("param.names", "disc.name", "reserved.md.names", "split.at")) {
  case(match.arg(what),
    param.names = CURVE_PARAMS,
    disc.name = DISC_PARAM,
    reserved.md.names = unname(RESERVED_NAMES),
    split.at = RESERVED_NAMES[["parameter"]]
  )
}

#' @rdname opm_files
#' @export
#'
select_colors <- function(
    set = c("w3c", "w3c.i", "nora", "nora.i", "brewer", "brewer.i",
      "roseo", "roseo.i")) {
  # Basic colour keywords from http://www.w3.org/TR/css3-color/ (accessed on
  # 29-8-2011), sorted darkest-first.
  w3c_colors <- function() c(black = "#000000", navy = "#000080",
    green = "#008000", maroon = "#800000", blue = "#0000FF", lime = "#00FF00",
    red = "#FF0000", teal = "#008080", purple = "#800080", olive = "#808000",
    gray = "#808080", aqua = "#00FFFF", fuchsia = "#FF00FF",
    yellow = "#FFFF00", silver = "#C0C0C0", white = "#FFFFFF")
  # Names of W3c colors (except white) sorted so as to maximize contrast
  # between adjacent colors. See pkgutils::max_rgb_contrast().
  sorted_w3c_colors <- function() w3c_colors()[c("teal", "purple", "olive",
    "black", "silver", "blue", "lime", "red", "aqua", "fuchsia", "yellow",
    "navy", "green", "maroon", "gray")]
  # Colours manually selected and sorted by Nora Buddruhs for maximum contrast.
  noras_colors <- function() c("midnightblue", "darkred", "darkgreen", "orange",
    "lightslateblue", "seashell4", "saddlebrown", "firebrick2",
    "palevioletred3", "purple4")
  # Shades of pink...
  roseo_colors <- function() c("maroon1", "palevioletred3", "hotpink1",
    "mediumvioletred", "violetred3", "deeppink3", "lightcoral", "pink1",
    "indianred3", "magenta1")
  # Colours from two ColorBrewer palettes, sorted so as to maximize contrast
  # between adjacent colors.
  brewer_colors <- function() c(
    "#CAB2D6", "#A6CEE3", "#80B1D3", "#CCEBC5", "#FDB462", "#8DD3C7",
    "#33A02C", "#B3DE69", "#B15928", "#FF7F00", "#1F78B4", "#B2DF8A",
    "#6A3D9A", "#E31A1C", "#FFED6F", "#FFFF99", "#FB8072", "#FFFFB3",
    "#FDBF6F", "#D9D9D9", "#FB9A99", "#FCCDE5", "#BC80BD", "#BEBADA"
  )
  case(match.arg(set),
    w3c = sorted_w3c_colors(), w3c.i = rev.default(sorted_w3c_colors()),
    nora = noras_colors(), nora.i = rev.default(noras_colors()),
    brewer = brewer_colors(), brewer.i = rev.default(brewer_colors()),
    roseo = roseo_colors(), roseo.i = rev.default(roseo_colors())
  )
}


################################################################################


#' Manipulate custom plate names or normalise predefined plate names
#'
#' Internal functions that must be in sync for manipulating custom plate names,
#' and internal functions for normalising predefined plate names.
#'
#' @param x Character vector.
#' @param subtype Logical scalar. See \code{\link{plate_type}}.
#' @return Character or logical vector.
#' @keywords internal
#'
custom_plate_is <- function(x) grepl("^Custom:", x, TRUE, TRUE)

#' @rdname custom_plate_is
#' @keywords internal
#'
custom_plate_proper <- function(x) substring(x, 8L, nchar(x))

#' @rdname custom_plate_is
#' @keywords internal
#'
custom_plate_prepend <- function(x) sprintf("CUSTOM:%s", x)

#' @rdname custom_plate_is
#' @keywords internal
#'
custom_plate_prepend_full <- function(x) sprintf("CUSTOM_FULL_NAME:%s", x)

#' @rdname custom_plate_is
#' @keywords internal
#'
custom_plate_normalize_proper <- function(x) {
  x <- sub("\\W+$", "", sub("^\\W+", "", x, FALSE, TRUE), FALSE, TRUE)
  toupper(gsub("\\W+", "-", x, FALSE, TRUE))
}

#' @rdname custom_plate_is
#' @keywords internal
#'
custom_plate_normalize <- function(x) {
  custom_plate_prepend(custom_plate_normalize_proper(custom_plate_proper(x)))
}

#' @rdname custom_plate_is
#' @keywords internal
#'
custom_plate_normalize_all <- function(x) {
  x <- ifelse(custom_plate_is(x), custom_plate_proper(x), x)
  custom_plate_prepend(custom_plate_normalize_proper(x))
}

#' @rdname custom_plate_is
#' @keywords internal
#'
custom_plate_exists <- function(x) {
  exists(x, MEMOIZED)
}

#' @rdname custom_plate_is
#' @keywords internal
#'
custom_plate_get <- function(x) {
  get(x, MEMOIZED)
}

#' @rdname custom_plate_is
#' @keywords internal
#'
custom_plate_assert <- function(x, coords) {
  if (custom_plate_exists(x)) {
    if (any(bad <- !coords %in% names(custom_plate_get(x))))
      stop("well coordinate missing from plate type '", x, "': ",
        coords[bad][1L])
  } else
    stop("unknown user-defined plate type: ", x)
  TRUE
}

#' @rdname custom_plate_is
#' @keywords internal
#'
custom_plate_set <- function(x, value) {
  if (exists(x, MEMOIZED))
    warning("overwriting well map for plate type ", x)
  MEMOIZED[[x]] <- value
  value
}

#' @rdname custom_plate_is
#' @keywords internal
#'
custom_plate_set_full <- function(x, value) {
  key <- custom_plate_prepend_full(custom_plate_proper(x))
  names(value) <- NULL
  if (exists(key, MEMOIZED) && !identical(value, get(key, MEMOIZED)))
    warning("overwriting full name for plate type ", x)
  MEMOIZED[[key]] <- value
  value
}

#' @rdname custom_plate_is
#' @keywords internal
#'
normalize_predefined_plate <- function(object, subtype = FALSE) {
  normalize_pm <- function(x, subtype) {
    x <- sub("^PMM", "PM-M", x, FALSE, TRUE)
    x <- sub("^PM-MTOX", "PM-M TOX", x, FALSE, TRUE)
    x <- sub("([A-Z]+)$", if (subtype)
      "-\\1"
    else
      "", x, FALSE, TRUE)
    sub("([^\\d])(\\d)([^\\d]|$)", "\\10\\2\\3", x, FALSE, TRUE)
  }
  normalize_sf <- function(x, subtype) {
    x <- if (subtype)
      sub("-$", "", sub(SP_PATTERN, "\\1-\\2", x, FALSE, TRUE), FALSE, TRUE)
    else
      sub(SP_PATTERN, "\\1", x, FALSE, TRUE)
    x <- sub("^(G|SF)([NP])", "SF-\\2", x, FALSE, TRUE)
    sub("^GENIII", "Gen III", x, FALSE, TRUE)
  }
  result <- toupper(gsub("\\W", "", object, FALSE, TRUE))
  pm <- grepl("^PM(M(TOX)?)?\\d+[A-Z]*$", result, FALSE, TRUE)
  result[pm] <- normalize_pm(result[pm], subtype)
  sf[sf] <- grepl(SP_PATTERN, result[sf <- !pm], FALSE, TRUE)
  result[sf] <- normalize_sf(result[sf], subtype)
  result[bad] <- object[bad <- !(pm | sf)]
  result
}


################################################################################


#' Plate type displayed or modified, registered or deleted
#'
#' Get the type of the OmniLog\eqn{\textsuperscript{\textregistered}}{(R)} plate
#' used in the measuring, normalise plate-type names, display known names, or
#' modify the plate type after inputting the plate data. Alternatively, register
#' or remove user-defined plate types.
#'
#' @param object \code{\link{OPM}}, \code{\link{OPMS}} or \code{\link{MOPMX}}
#'   object, or character vector of original plate name(s), or factor, or
#'   logical scalar. If missing, the function displays the plate types \pkg{opm}
#'   knows about. If a logical scalar, the behaviour is the same, but optionally
#'   restricted to the user-defined or the \pkg{opm}-defined plate types.
#'
#'   For \code{register_plate}, \code{object} is either missing (the easiest way
#'   to apply the function), causing the arguments within \code{...} (which
#'   should be named) to be used, if any, a named list of \code{NULL} values or
#'   character vectors, or a character vector whose elements are interpretable
#'   as file names. See below for details on the input format.
#' @param full Logical scalar. If \code{TRUE}, add (or replace by) the full name
#'   of the plate type (if available); otherwise, return it as-is.
#' @param in.parens Logical scalar. This and the five next arguments work like
#'   the eponymous ones of \code{\link{wells}}, but here are applied to the
#'   plate name. See there for details.
#' @param max Numeric scalar.
#' @param clean Logical scalar.
#' @param brackets Logical scalar.
#' @param word.wise Logical scalar.
#' @param paren.sep Character scalar.
#' @param downcase Logical scalar.
#' @param normalize Logical scalar. Attempt to normalise the plate-type string
#'   before interpreting it?
#' @param subtype Logical scalar. Keep the plate subtype indicator, if any? Only
#'   relevant for the character or factor method.
#' @param to Character scalar indicating the plate type. User-defined plate
#'   types must be given literally. For generation-III plates, use
#'   \kbd{gen.iii}; for the
#'   EcoPlate\eqn{\textsuperscript{\texttrademark}}{(TM)}, use \kbd{eco}; the
#'   remaining allowed values are only \kbd{sf.n2}, \kbd{sf.p2}, \kbd{an2},
#'   \kbd{ff} and \kbd{yt}, but matching is case-insensitive.
#'
#'   A character vector of length greater than one can be passed to the
#'   \code{\link{MOPMX}} method, which recycles its \code{to} argument.
#'
#' @param ... Optional arguments passed between the methods. For
#'   \code{register_plate}, named arguments to be used if \code{object} is
#'   missing.
#'
#' @return Character scalar in the case of the \code{\link{OPM}} and
#'   \code{\link{OPMS}} methods of \code{plate_type}, otherwise a character
#'   vector with the same length than \code{object}, or a corresponding factor.
#'   If \code{object} is not given, a character vector of normalised plate-type
#'   names.
#'
#'   \code{gen_iii} returns a novel \code{\link{OPMX}} object.
#'
#'   \code{register_plate} returns a logical vector whose values indicate
#'   whether information was registered or deleted and whose names are the
#'   normalised plate-type names.
#'
#' @details The \code{\link{OPM}} and \code{\link{OPMS}} methods of
#'   \code{plate_type} are convenience methods for one of the more important
#'   entries of \code{\link{csv_data}} with additional options useful for
#'   creating plot titles.
#'
#'   The character method normalises the names of
#'   OmniLog\eqn{\textsuperscript{\textregistered}}{(R)} \acronym{PM} plates to
#'   the internally used naming scheme. Unrecognised names are returned
#'   unchanged. This needs not normally be called by the \pkg{opm} user but
#'   might be of interest.
#'
#'   Factors are treated by passing their levels through the character method.
#'
#'   If a logical scalar is given as \code{object} argument, \code{TRUE}
#'   restricts the output to user-defined plate types (an empty set by default),
#'   \code{FALSE} to the plate types that ship with \pkg{opm}, and \code{NA}
#'   shows all plates.
#'
#'   \code{gen_iii} change the plate type of an \code{\link{OPM}} object to
#'   \sQuote{Generation III} or another plate type. This is currently the only
#'   function to change plate names. It is intended for Generation-III or other
#'   plates that were not devised for the OmniLog instrument but can be run just
#'   like \acronym{PM} plates. Usually they will be annotated as some
#'   \acronym{PM} plate by the
#'   OmniLog\eqn{\textsuperscript{\textregistered}}{(R)} system. In contrast,
#'   input ID-mode plates are automatically detected (see
#'   \code{\link{read_single_opm}}). For this reason, \code{gen_iii} does not
#'   enable changes to \acronym{PM} plate types.
#'
#'   User-defined plate types are allowed but need the according prefix (which
#'   must currently case-insensitively match \sQuote{Custom:}), even though
#'   additional normalisation is done. It is an error to set a user-defined
#'   plate type that has not beforehand been registered with
#'   \code{register_plate}.
#'
#'   The actual spelling of the plate type used might (in theory) differ between
#'   distinct versions of \pkg{opm} but is internally consistent. It is an error
#'   to set one of the \acronym{PM} plate types or to assign an unknown plate
#'   type.
#'
#'   Two kinds of information can be registered for user-defined plates: the
#'   full name of the plate and/or the full names of the substrates for all
#'   well coordinates. Both kinds of information can be deleted again. In any
#'   case, the name of the argument within \code{...} or within \code{object}
#'   given as list must indicate the plate type. Normalisation is done, as well
#'   as adding the usual prefix for user-defined plates.
#'
#'   For registering a full plate name, an unnamed character scalar must be
#'   provided. For registering the mapping from well coordinates to substrate
#'   names, a named character vector must be provided with the names indicating
#'   the well coordinates and the elements indicating the according substrate
#'   names. Alternatively, a matrix or data frame can be provided that imitates
#'   that physical structure of the plate. That is, the rows are the plate rows
#'   (A, B, C, ...) and the columns are the plate columns (1, 2, 3, ...). If
#'   row or column names are used, they are honoured.
#'
#'   For deleting a user-defined plate, an empty value (such as \code{NULL} or
#'   an empty vector) must be provided. Deletion is done for both full plate
#'   names and mappings from well coordinates to substrate names. It is ignored
#'   whether or not this information had been registered beforehand.
#'
#' @export
#' @family naming-functions
#' @seealso base::strtrim base::abbreviate base::gsub
#' @keywords attribute utilities character manip
#' @examples
#'
#' ## 'OPM' method
#' (x <- plate_type(vaas_1, full = FALSE))
#' (y <- plate_type(vaas_1, full = TRUE))
#' (z <- plate_type(vaas_1, full = TRUE, in.parens = FALSE))
#' # strings lengths differ depending on the selection
#' stopifnot(nchar(x) < nchar(y), nchar(z) < nchar(y))
#'
#' \dontrun{
#'
#' # Splitting a list of 'OPM' objects according to the plate type is easy:
#' x <- split(x), sapply(x, plate_type))
#' # but see also opms() and read_opm(), which can do this internally
#' }
#'
#' ## 'OPMS' method
#' (xx <- plate_type(vaas_4, full = FALSE))
#' # plate type is guaranteed to be uniform within an OPMS object
#' stopifnot(identical(x, xx))
#'
#' ## character and factor methods
#'
#' # Entirely unrecognized strings are returned as-is
#' (x <- plate_type(letters))
#' stopifnot(identical(x, letters))
#'
#' # Something more realistic
#' (x <- plate_type(y <- c("PM1", "PM-11C", "PMM04-a"), subtype = TRUE))
#' stopifnot(x != y)
#'
#' # Factors
#' (z <- plate_type(as.factor(y), subtype = TRUE))
#' stopifnot(is.factor(z), z == x) # same result after conversion
#'
#' ## 'missing' method
#' (x <- plate_type())
#' stopifnot(is.character(x), plate_type(vaas_1) %in% x)
#'
#' ## changing the plate type
#'
#' # 'OPM' method
#' plate_type(copy <- gen_iii(vaas_1))
#' stopifnot(identical(vaas_1, copy)) # the data set already had that plate type
#' plate_type(copy <- gen_iii(vaas_1, "eco")) # which is wrong, actually
#' stopifnot(!identical(vaas_1, copy))
#'
#' # 'OPMS' method
#' plate_type(copy <- gen_iii(vaas_4))
#' stopifnot(identical(vaas_4, copy)) # as above
#' plate_type(copy <- gen_iii(vaas_4, "eco"))
#' stopifnot(!identical(vaas_4, copy)) # as above
#'
#' ## registering plate types
#'
#' # well map and full name of a plate can be simultaneously registered
#' register_plate(myplate = c(A01 = "Glucose", A02 = "Fructose"),
#'   myplate = "Simple fake test plate")
#' # note standardization of name
#' stopifnot("CUSTOM:MYPLATE" %in% plate_type(TRUE))
#' # queries can be done ignoring case differences
#' listing(wells(plate = "custom:myplate"))
#'
#' # input/output of plate types
#' plate.file <- tempfile()
#' write(to_yaml(listing(wells(plate = "custom:myplate"))), plate.file)
#' register_plate(plate.file)
#' unlink(plate.file) # tidying up
#'
#' # erasing this plate type again; this will delete well map and full name
#' register_plate(myplate = NULL)
#' stopifnot(!"CUSTOM:MYPLATE" %in% plate_type(TRUE))
#'
setGeneric("plate_type", function(object, ...) standardGeneric("plate_type"))

setMethod("plate_type", OPM, function(object, ..., normalize = FALSE,
    subtype = FALSE) {
  plate_type(object = object@csv_data[[CSV_NAMES[["PLATE_TYPE"]]]], ...,
    normalize = normalize, subtype = subtype)
}, sealed = SEALED)

setMethod("plate_type", MOPMX, function(object, ..., normalize = FALSE,
    subtype = FALSE) {
  vapply(X = object@.Data, FUN = plate_type, FUN.VALUE = "", ...,
    normalize = normalize, subtype = subtype)
}, sealed = SEALED)

setMethod("plate_type", "character", function(object, full = FALSE,
    in.parens = TRUE, max = opm_opt("max.chars"), clean = TRUE,
    brackets = FALSE, word.wise = FALSE, paren.sep = " ", downcase = FALSE,
    normalize = TRUE, subtype = FALSE) {
  do_normalize <- function(object, subtype) {
    is.custom <- custom_plate_is(object)
    object[!is.custom] <- normalize_predefined_plate(object[!is.custom],
      subtype)
    object[is.custom] <- custom_plate_normalize(object[is.custom])
    object
  }
  orig_and_full <- function(orig, full.name) {
    if (downcase)
      full.name <- substrate_info(full.name, "downcase")
    if (in.parens)
      add_in_parens(str.1 = orig, str.2 = full.name, max = max,
        clean = clean, brackets = brackets, word.wise = word.wise,
        paren.sep = paren.sep)
    else
      trim_string(str = full.name, max = max, clean = clean,
        word.wise = word.wise)
  }
  expand_predefined <- function(x) {
    pos <- match(x, names(PLATE_MAP))
    ok <- !is.na(pos)
    for (name in x[!ok])
      warning("cannot find full name of plate ", name)
    x[ok] <- orig_and_full(x[ok], PLATE_MAP[pos[ok]])
    x
  }
  expand_custom <- function(x) {
    if (!length(x))
      return(x)
    n <- custom_plate_prepend_full(custom_plate_proper(x))
    ok <- vapply(n, exists, NA, MEMOIZED)
    for (name in x[!ok])
      warning("cannot find full name of plate ", name)
    x[ok] <- orig_and_full(x[ok], unlist(mget(n[ok], MEMOIZED), FALSE, FALSE))
    x
  }
  LL(full, downcase, in.parens, normalize, subtype)
  result <- if (normalize)
    do_normalize(object, subtype)
  else
    object
  if (!full)
    return(result)
  is.custom <- custom_plate_is(result)
  result[!is.custom] <- expand_predefined(result[!is.custom])
  result[is.custom] <- expand_custom(result[is.custom])
  result
}, sealed = SEALED)

setMethod("plate_type", "factor", function(object, ...) {
  map_values(object = object, mapping = plate_type, ...)
}, sealed = SEALED)

setMethod("plate_type", "missing", function(object, ...) {
  x <- ls(MEMOIZED)
  plate_type(c(names(PLATE_MAP), x[custom_plate_is(x)]), ...)
}, sealed = SEALED)

setMethod("plate_type", "logical", function(object, ...) {
  if (is.na(L(object))) {
    x <- ls(MEMOIZED)
    x <- c(names(PLATE_MAP), x[custom_plate_is(x)])
  } else if (object) {
    x <- ls(MEMOIZED)
    x <- x[custom_plate_is(x)]
  } else {
    x <- names(PLATE_MAP)
  }
  plate_type(x, ...)
}, sealed = SEALED)

#= gen_iii plate_type

#' @rdname plate_type
#' @export
#'
setGeneric("gen_iii", function(object, ...) standardGeneric("gen_iii"))

setMethod("gen_iii", OPM, function(object, to = "gen.iii") {
  if (custom_plate_is(L(to))) {
    to <- custom_plate_normalize(to)
    custom_plate_assert(to, colnames(object@measurements)[-1L])
  } else
    to <- SPECIAL_PLATES[[match.arg(tolower(to), names(SPECIAL_PLATES))]]
  object@csv_data[[CSV_NAMES[["PLATE_TYPE"]]]] <- to
  object
}, sealed = SEALED)

setMethod("gen_iii", OPMS, function(object, ...) {
  object@plates <- lapply(X = object@plates, FUN = gen_iii, ...)
  object
}, sealed = SEALED)

setMethod("gen_iii", MOPMX, function(object, ...) {
  object@.Data <- mapply(FUN = gen_iii, object = object@.Data, ...,
    MoreArgs = NULL, SIMPLIFY = FALSE, USE.NAMES = FALSE)
  object
}, sealed = SEALED)

#= register_plate plate_type

#' @rdname plate_type
#' @export
#'
setGeneric("register_plate",
  function(object, ...) standardGeneric("register_plate"))

setMethod("register_plate", "character", function(object, ...) {
  x <- do.call(c, lapply(object, function(file) tryCatch(yaml.load_file(file),
    error = function(e) readRDS(file))))
  x <- mapply(FUN = function(d, n) {
      names(d) <- rep.int(n, length(d))
      d
    }, d = x, n = names(x), SIMPLIFY = FALSE, USE.NAMES = FALSE)
  register_plate(do.call(c, x), ...)
}, sealed = SEALED)

setMethod("register_plate", "missing", function(object, ...) {
  register_plate(list(...))
}, sealed = SEALED)

setMethod("register_plate", "list", function(object, ...) {
  valid_names <- function(n) length(n) && !any(is.na(n)) && all(nzchar(n))
  prepare_names <- function(n) {
    if (!valid_names(n))
      stop("all arguments must be validly named")
    n <- ifelse(custom_plate_is(n), custom_plate_proper(n), n)
    custom_plate_normalize_proper(n)
  }
  convert_rectangular_coords <- function(x) {
    if (!length(j <- as.integer(colnames(x))))
      j <- seq_len(ncol(x))
    if (!length(i <- rownames(x)))
      i <- rep(LETTERS, length.out = nrow(x))
    n <- vapply(i, sprintf, character(length(j)), fmt = "%s%02i", j)
    structure(c(t(x)), names = c(n))
  }
  prepare_well_map <- function(x) {
    if (inherits(x, "well_coords_map")) {
      case(ncol(x), stop("'well_coords_map' object has zero columns"),
        x <- x[, 1L], {
          warning("discarding additional columns in 'well_coords_map' object")
          x <- x[, 1L]
        })
    } else if (is.data.frame(x)) {
      for (i in which(vapply(x, is.factor, NA)))
        x[, i] <- as.character(x[, i])
      x <- convert_rectangular_coords(as.matrix(x))
    } else if (is.matrix(x)) {
      x <- convert_rectangular_coords(x)
    } else {
      names(x) <- clean_coords(names(x))
    }
    storage.mode(x) <- "character"
    if (dup <- anyDuplicated(names(x)))
      stop("duplicate well coordinate provided: ", names(x)[dup])
    x
  }
  insert_plate_types <- function(x) {
    named <- vapply(lapply(x, names), valid_names, NA) |
      vapply(x, is.data.frame, NA) | vapply(x, is.matrix, NA)
    if (any(vapply(x, length, 0L) > 1L & !named))
      stop("element unnamed but not of length 1")
    x[named] <- lapply(x[named], prepare_well_map)
    names(x) <- ifelse(named, custom_plate_prepend(names(x)),
      custom_plate_prepend_full(names(x)))
    list2env(x, MEMOIZED)
  }
  remove_plate_types <- function(x) {
    x <- c(custom_plate_prepend(x), custom_plate_prepend_full(x))
    suppressWarnings(rm(list = x, envir = MEMOIZED))
  }
  if (!missing(...))
    warning("arguments other than 'object' are ignored")
  names(object) <- prepare_names(names(object))
  nonempty <- vapply(object, length, 0L) > 0L
  insert_plate_types(object[nonempty])
  remove_plate_types(names(object)[!nonempty])
  structure(nonempty, names = custom_plate_prepend(names(object)))
}, sealed = SEALED)


################################################################################
################################################################################
#
# Helper functions for package, plate, substrate, well, and curve parameter
# names
#


#' Name of this package
#'
#' Generate character string describing this package, optionally with its
#' version.
#'
#' @param version Logical scalar indicating whether or not to append version
#'   information.
#' @details The version might be wrong if this function is called after loading
#'   the files with \code{source} instead of \code{library}. If it is
#'   unavailable, it is silently ignored.
#' @return One- or two-element character scalar.
#' @keywords internal
#'
opm_string <- function(version = FALSE) {
  x <- "opm"
  if (!version)
    return(x)
  if (exists("opm.version", MEMOIZED))
    y <- MEMOIZED$opm.version
  else
    MEMOIZED$opm.version <- y <- tryCatch(
      as.character(packageVersion(x)), error = function(e) {
        warning(sprintf("cannot find %s version", x))
        UNKNOWN_VERSION
      })
  c(x, y)
}


################################################################################


#' Check CAS number
#'
#' Check whether a \acronym{CAS} number is internally valid.
#'
#' @param x Character vector.
#' @return Named logical vector. Input \code{NA} values yield \code{NA}.
#' @details The check tolerates a prepended \sQuote{CAS} indicator, separated
#'   by whitespace, but neither appended or prepended whitespace.
#' @references \url{http://www.cas.org/content/chemical-substances/checkdig}
#' @keywords internal
#'
is_cas <- function(x) {
  ms <- function(x, m, i) { # get the substring from the chosen capture
    start <- attr(m, "capture.start")[, i]
    substr(x, start, start + attr(m, "capture.length")[, i] - 1L)
  }
  cmp <- function(digits, check) { # compare check digits
    sum_up <- function(x) sum(seq.int(length(x), 1L) * as.numeric(x)) / 10
    s <- vapply(strsplit(digits, "", TRUE), sum_up, 0)
    abs(s - floor(s) - as.numeric(check) / 10) < .Machine$double.eps ^ 0.5
  }
  m <- regexpr("^(?:CAS\\s+)?(\\d{2,7})-(\\d{2})-(\\d)$", x, TRUE, TRUE)
  f <- attr(m, "match.length") > 0L
  ok <- f & !is.na(x)
  f[ok] <- cmp(paste0(ms(x, m, 1L)[ok], ms(x, m, 2L)[ok]), ms(x, m, 3L)[ok])
  structure(f, names = x)
}


################################################################################


#' Curve-parameter mapping
#'
#' Create a mapping for names of curve parameters.
#'
#' @param subset \code{NULL} or character vector. Use only these values?
#' @param ci Logical scalar. Also return CI names?
#' @param plain Logical scalar. Return the plain base names only, ignoring
#'   \code{subset} and \code{ci}?
#' @param opm.fast Logical scalar. Produce the mapping for the
#'   \sQuote{opm-fast} method instead?
#' @param disc Logical scalar. Add the name used to select discretised values?
#' @return Named list with old names as keys, new ones as values.
#' @keywords internal
#'
map_param_names <- function(subset = NULL, ci = TRUE, plain = FALSE,
    opm.fast = FALSE, disc = FALSE) {
  part.1 <- as.list(CURVE_PARAMS)
  names(part.1) <- if (opm.fast)
    c("mu", "lambda", "A", "AUC")
  else
    c("mu", "lambda", "A", "integral")
  if (disc)
    part.1$disc <- DISC_PARAM
  if (plain)
    return(part.1)
  if (length(subset) > 0L) {
    subset <- match.arg(subset, part.1, several.ok = TRUE)
    part.1 <- part.1[part.1 %in% subset]
  }
  if (ci) {
    part.2 <- paste(part.1, "CI95 low")
    part.3 <- paste(part.1, "CI95 high")
    if (opm.fast) {
      names(part.2) <- sprintf("%s.ci.low", names(part.1))
      names(part.3) <- sprintf("%s.ci.high", names(part.1))
    } else {
      names(part.2) <- sprintf("ci95.%s.bt.lo", names(part.1))
      names(part.3) <- sprintf("ci95.%s.bt.up", names(part.1))
    }
  } else {
    part.2 <- NULL
    part.3 <- NULL
  }
  if (opm.fast)
    names(part.1) <- sprintf("%s.point.est", names(part.1))
  else
    names(part.1) <- sprintf("%s.spline", names(part.1))
  c(part.1, part.2, part.3)
}


################################################################################


#' Translate well coordinates (or names or plate positions).
#'
#' Translate well coordinates to numeric indexes, or clean well indexes given
#' as character vector, or translate well names (which are basically their
#' coordinates on the plate) to substrate names, given the name of the plate.
#' (The user-level function for this is \code{\link{wells}}.) Alternatively,
#' get the substrate from full well names, potentially containing well
#' coordinate together with the substrate name.
#'
#' @param x Vector, formula or missing. Basically any \R object. The cleaning
#'   functions expect a character vector.
#' @param names Character vector. Ignored unless \code{x} is a formula.
#' @param wells Character vector of original well names (coordinates on the
#'   plate).
#' @param plate Character scalar. The type of the plate. See
#'   \code{\link{plate_type}}.
#' @param in.parens Logical scalar. See \code{\link{wells}}.
#' @param brackets Logical scalar. See \code{\link{wells}}.
#' @param paren.sep Character scalar. See \code{\link{wells}}.
#' @param downcase Logical scalar. See \code{\link{wells}}.
#' @param rm.num Logical scalar. See \code{\link{wells}}.
#' @param ... Arguments that can be passed to both \code{\link{add_in_parens}}
#'   and \code{\link{trim_string}}.
#' @return Either \code{x}, \code{TRUE} or (if a formula) the result of
#'   evaluating \code{x} in the context of \code{names}, converted to a mapping
#'   from elements to indexes. A character vector in the case of
#'   \code{map_well_names}.
#' @keywords internal
#'
well_index <- function(x, names) {
  if (missing(x))
    TRUE
  else if (is.character(x))
    clean_coords(x)
  else if (inherits(x, "formula"))
    eval(x[[length(x)]], structure(as.list(seq_along(names)), names = names))
  else
    x
}

#' @rdname well_index
#'
clean_coords <- function(x) {
  do_clean <- function(x) {
    x <- sub("\\s+$", "", sub("^\\s+", "", x, FALSE, TRUE), FALSE, TRUE)
    sprintf("%s%02i", toupper(substr(x, 1L, 1L)),
      as.integer(sub("^[A-Za-z]+", "", x, FALSE, TRUE)))
  }
  if (any(bad <- !grepl("^[A-Z]\\d{2,2}$", x, FALSE, TRUE)))
    x[bad] <- do_clean(x[bad])
  x
}

#' @rdname well_index
#'
clean_plate_positions <- function(x) {
  x <- lapply(strsplit(x, "\\W+", FALSE, TRUE), function(s) s[nzchar(s)])
  n <- as.integer(vapply(x, `[[`, "", 1L))
  x <- toupper(substr(vapply(x, `[`, "", 2L), 1L, 1L))
  x[is.na(x)] <- "?" # Microstation positions are only integers
  sprintf("%02i-%s", n, x)
}

#' @rdname well_index
#'
map_well_names <- function(wells, plate, in.parens = FALSE, brackets = FALSE,
    paren.sep = " ", downcase = FALSE, rm.num = FALSE,
    max = opm_opt("max.chars"), ...) {
  if ((L(paren.sep) == "@"))
    return(sprintf("%s@%s", wells, plate))
  if (custom_plate_is(plate)) {
    if (custom_plate_exists(plate))
      res <- custom_plate_get(plate)[wells]
    else
      res <- NULL
  } else {
    if (is.na(pos <- match(plate, colnames(WELL_MAP))))
      res <- NULL
    else
      res <- WELL_MAP[wells, pos, "name"]
  }
  if (is.null(res)) {
    warning("cannot find plate type ", plate)
    return(trim_string(str = wells, max = max, ...))
  }
  if (rm.num)
    res <- remove_concentration(res)
  if (downcase)
    res <- substrate_info(res, "downcase")
  if (in.parens)
    add_in_parens(str.1 = wells, str.2 = res, brackets = brackets,
      paren.sep = paren.sep, max = max, ...)
  else
    trim_string(str = res, max = max, ...)
}

#' @rdname well_index
#'
well_to_substrate <- function(x, plate) {
  get_name <- function(x, plate) wells(x, TRUE, FALSE, plate = plate)[, 1L]
  if (length(plate)) {
    if (all(grepl(SUBSTRATE_PATTERN[["any"]], x, FALSE, TRUE)))
      get_name(substr(x, 1L, 3L), plate)
    else
      x # assume plain substrate names without wells as prefix
  } else if (all(grepl("^[A-Z][0-9]{2}@", x, FALSE, TRUE))) {
    plate <- as.factor(substr(x, 5L, nchar(x)))
    pos <- split.default(seq_along(x), plate)
    x <- split.default(substr(x, 1L, 3L), plate)
    x <- mapply(get_name, x, names(x), SIMPLIFY = FALSE)
    result <- character(length(plate))
    for (i in seq_along(x))
      result[pos[[i]]] <- x[[i]]
    result
  } else {
    for (p in SUBSTRATE_PATTERN[c("paren", "bracket")]) {
      m <- regexpr(p, x, FALSE, TRUE)
      if (all(attr(m, "match.length") > 0L))
        return(get_partial_match(1L, m, x))
    }
    x
  }
}


################################################################################


#' Create sentences
#'
#' Create a textual (listing-like) description.
#'
#' @param x Logical vector.
#' @param html Logical scalar.
#' @param ... Optional arguments passed to and from other methods.
#' @return Character vector, one element per sentence.
#' @keywords internal
#'
to_sentence <- function(x, ...) UseMethod("to_sentence")

#' @rdname to_sentence
#' @method to_sentence logical
#' @export
#'
to_sentence.logical <- function(x, html, ...) {
  sentence <- function(x, what) {
    if (length(x)) {
      if (html)
        x <- substrate_info(x, "html")
      sprintf("%s for %s.", what, listing(x, style = "sentence"))
    } else
      ""
  }
  LL(html)
  isna <- is.na(x)
  n <- c("Positive", "Negative", "Ambiguous")
  result <- c(sentence(names(x)[x & !isna], n[1L]),
    sentence(names(x)[!x & !isna], n[2L]), sentence(names(x)[isna], n[3L]))
  if (html)
    result <- sprintf("<div>%s</div>", result)
  names(result) <- n
  result
}


################################################################################


#' Listing of well names
#'
#' Get the names of the wells contained in an \code{\link{OPMX}} object.
#' Optionally the full substrate names can be added in parentheses or brackets
#' or used instead of the coordinate, and trimmed to a given length. The
#' \code{listing} methods create a textual listing of the discretised values.
#' (See \code{\link{do_disc}} for generating discretised data.) This is useful
#' to describe OmniLog\eqn{\textsuperscript{\textregistered}}{(R)} phenotype
#' microarray results in a scientific manuscript.
#'
#' @param object \code{\link{OPM}} object, \code{\link{OPMS}} object or well
#'   name or index. If missing, defaults to the selection of all possible
#'   wells (for the default plate type, see below).
#' @param full Logical scalar. Return the full names of the wells (if available)
#'   or just their coordinates on the plate? The following arguments have no
#'   effect if \code{full} is \code{FALSE}.
#' @param in.parens Logical scalar. If \code{TRUE}, add the full name of the
#'   substrate in parentheses (or brackets) after the original name. If
#'   \code{FALSE}, replace by the full substrate name. Note that adding in
#'   parentheses (or brackets) is only done if the trimmed substrate names are
#'   not empty.
#' @param max Numeric scalar. Maximum number of characters allowed in the names.
#'   Longer names are truncated and the truncation is indicated by appending a
#'   dot.
#' @param brackets Logical scalar. Use brackets instead of parentheses?
#' @param clean Logical scalar. If \code{TRUE}, clean trimmed end of full
#'   substrate name from non-word characters; use an empty string if only the
#'   dot remained.
#' @param word.wise Logical scalar. If \code{TRUE}, abbreviation works by
#'   truncating each word separately, and removing vowels first.
#' @param paren.sep Character scalar. What to insert before the opening
#'   parenthesis (or bracket). Currently only zero to many whitespace characters
#'   are allowed. The ability to insert a line break is the main purpose of this
#'   argument. Using the \sQuote{at sign} as value is the only alternative and
#'   also special, as it causes the plate name itself to be appended to the well
#'   coordinate (after an \sQuote{at sign}, without parentheses or brackets). So
#'   mapping is not actually done in that case but the resulting names are
#'   understood by certain other \pkg{opm} methods which can conduct the mapping
#'   at a later stage.
#' @param downcase Logical scalar indicating whether full names should be
#'   (carefully) converted to lower case. This uses \code{\link{substrate_info}}
#'   in \kbd{downcase} mode; see there for details.
#' @param rm.num Logical scalar indicating whether numbering (used in the case
#'   of replicated substrates per plate) should be stripped from the end of the
#'   full well names.
#' @param plate Name of the plate type. Several ones can be given unless
#'   \code{object} is of class \code{\link{OPM}} or \code{\link{OPMS}}.
#'   Normalisation as in \code{\link{plate_type}} is applied before searching
#'   for the substrate names but otherwise the match must be exact.
#' @param simplify Logical scalar indicating whether the result should be
#'   simplified to a vector. This will never be done if more than a single
#'   column is contained, i.e. if data for more than a single plate type are
#'   queried for.
#' @param ... Optional arguments passed between the methods.
#'
#' @param x \code{\link{OPMD}}, \code{\link{OPMS}} or \code{well_coords_map}
#'   object.
#' @param as.groups Key suitable for querying the metadata, or \code{NULL}. If
#'   non-empty, passed as eponymous argument to \code{\link{extract}}. Thus
#'   \code{TRUE} and \code{FALSE} can be used, creating either a single group or
#'   one per plate. The extracted metadata define groups for which the
#'   discretised data are aggregated.
#'
#'   If \code{x} is an \code{\link{OPMD}} object and \code{as.groups} is not
#'   empty, it is used to create the row name of the single row of the resulting
#'   \code{OPMS_Listing} object. Otherwise an \code{OPMD_Listing} object is
#'   produced.
#' @param cutoff Numeric scalar used if \sQuote{as.groups} is non-empty. If the
#'   relative frequency of the most frequent entry within the discretised values
#'   to be joined is below that cutoff, \code{NA} is used. Ignored if \code{x}
#'   is an \code{\link{OPMD}} object but added to the result if \code{as.groups}
#'   is non-empty.
#' @param html Logical scalar. Convert to \acronym{HTML}? This involves Greek
#'   letters and paragraph (\sQuote{div}) tags.
#' @param sep Character scalar used for joining the \sQuote{as.groups} entries
#'   (if any).
#' @param exact Logical scalar passed to \code{\link{metadata}}.
#' @param strict Logical scalar also passed to \code{\link{metadata}}.
#'
#' @return The \code{wells} methods return a named character vector or a named
#'   matrix of the S3 class \code{well_coords_map}, depending on \code{simplify}
#'   and \code{plate}.
#'
#'   The return value of the \code{listing} methods for \code{\link{OPMX}}
#'   objects is a character vector or matrix with additional class attribute
#'   \code{OPMD_Listing} or \code{OPMS_Listing}.
#'
#'   The \code{well_coords_map} method creates a nested list of the class
#'   \code{well_coords_listing} which can be used in conjunction with
#'   \code{\link{to_yaml}} or \code{saveRDS} for externally storing well maps.
#'   See the examples for details.
#' @export
#' @family naming-functions
#' @seealso base::strtrim base::abbreviate
#' @keywords attribute character category
#' @details
#'   Do not confuse \code{wells} this with \code{\link{well}}. The purpose of
#'   the \code{\link{OPM}} and \code{\link{OPMS}} methods for \code{wells}
#'   should be obvious. The default method is intended for providing a quick
#'   overview of the substrates contained in one to several plates if
#'   \code{full} is \code{TRUE}. If \code{full} is \code{FALSE}, it can be used
#'   to study the effect of the well-index translation and well-name
#'   normalisation approaches as used by \pkg{opm}, particularly by the
#'   sub-creation methods (see \code{\link{[}}).
#' @examples
#'
#' ## wells() 'OPM' method
#' (x <- wells(vaas_1, full = FALSE))[1:10]
#' (y <- wells(vaas_1, full = TRUE))[1:10]
#' (z <- wells(vaas_1, full = TRUE, in.parens = FALSE))[1:10]
#' # string lengths differ depending on selection
#' stopifnot(nchar(x) < nchar(y), nchar(z) < nchar(y))
#'
#' ## wells() 'OPM' method
#' (xx <- wells(vaas_4, full = FALSE))[1:10]
#' # wells are guaranteed to be uniform within OPMS objects
#' stopifnot(identical(x, xx))
#'
#' ## wells() default method
#' x <- c("A01", "B10")
#' (y <- wells(x, plate = "PM1"))
#' stopifnot(nchar(y) > nchar(x))
#' (z <- wells(x, plate = "PM1", in.parens = TRUE))
#' stopifnot(nchar(z) > nchar(y))
#' # formula yields same result
#' stopifnot(y == wells(~ c(A01, B10), plate = "PM1"))
#' # querying for several plate types at once
#' (y <- wells(~ c(A01, B10), plate = c("PM2", "PM3", "PM10")))
#' stopifnot(dim(y) == c(2, 3))
#' (z <- listing(y)) # create a printable nested list
#' stopifnot(is.list(z), sapply(z, is.list), names(z) == colnames(y))
#' # using a sequence of well coordinates
#' stopifnot(nrow(wells(~ C02:C06)) == 5) # well sequence
#' stopifnot(nrow(wells(plate = "PM1")) == 96) # all wells by default
#'
#' ## listing() 'OPMD' method
#'
#' # this yields one sentence for each kind of reaction:
#' (x <- listing(vaas_1, NULL))
#' stopifnot(inherits(x, "OPMD_Listing"), is.character(x), length(x) == 3,
#'   !is.null(names(x)))
#'
#' # create an 'OPMS_Listing' object
#' (y <- listing(vaas_1, ~ Species + Strain))
#' stopifnot(inherits(y, "OPMS_Listing"), is.matrix(y), dim(y) == c(1, 3),
#'   y == x, colnames(y) == names(x), !is.null(rownames(y)))
#'
#' # including HTML tags
#' (y <- listing(vaas_1, NULL, html = TRUE))
#' stopifnot(inherits(y, "OPMD_Listing"), is.character(x), nchar(y) > nchar(x),
#'   !is.null(names(x)))
#'
#' ## listing() 'OPMS' method
#'
#' # no grouping, no names (numbering used instead for row names)
#' (x <- listing(vaas_4[1:2], as.groups = NULL))
#' stopifnot(inherits(x, "OPMS_Listing"), is.matrix(x), dim(x) == c(2, 3))
#' stopifnot(!is.null(rownames(x)), !is.null(colnames(x)))
#' (y <- listing(vaas_4[1:2], as.groups = FALSE)) # alternative
#' stopifnot(identical(x, y))
#'
#' # in effect no grouping, but names
#' (x <- listing(vaas_4[1:2], as.groups = list("Species", "Strain")))
#' stopifnot(inherits(x, "OPMS_Listing"), is.matrix(x), dim(x) == c(2, 3))
#' stopifnot(!is.null(rownames(x)), !is.null(colnames(x)))
#'
#' # only single group for all plates
#' (y <- listing(vaas_4[1:2], as.groups = TRUE))
#' stopifnot(inherits(y, "OPMS_Listing"), is.matrix(y), dim(y) == c(1, 3))
#' stopifnot(!is.null(rownames(x)), !is.null(colnames(x)))
#'
#' # two groups
#' (x <- listing(vaas_4, as.groups = list("Species")))
#' stopifnot(inherits(x, "OPMS_Listing"), is.matrix(x), dim(x) == c(2, 3))
#' stopifnot(!is.null(rownames(x)), !is.null(colnames(x)))
#'
setGeneric("wells", function(object, ...) standardGeneric("wells"))

setMethod("wells", OPM, function(object, full = FALSE, in.parens = TRUE,
    max = opm_opt("max.chars"), brackets = FALSE, clean = TRUE,
    word.wise = FALSE, paren.sep = " ", downcase = FALSE, rm.num = FALSE,
    plate = plate_type(object), simplify = TRUE) {
  LL(full, simplify, plate)
  x <- colnames(object@measurements)[-1L]
  if (!missing(plate))
    plate <- if (custom_plate_is(plate))
      custom_plate_normalize(plate)
    else
      normalize_predefined_plate(plate)
  if (full)
    x <- structure(map_well_names(x, plate, in.parens = in.parens,
      max = max, brackets = brackets, clean = clean, word.wise = word.wise,
      paren.sep = paren.sep, downcase = downcase, rm.num = rm.num), names = x)
  if (simplify)
    return(x)
  x <- matrix(x, length(x), 1L, FALSE, list(names(x), plate))
  class(x) <- "well_coords_map"
  x
}, sealed = SEALED)

setMethod("wells", "ANY", function(object, full = TRUE, in.parens = FALSE,
    max = opm_opt("max.chars"), brackets = FALSE, clean = TRUE,
    word.wise = FALSE, paren.sep = " ", downcase = FALSE, rm.num = FALSE,
    plate = "PM01", simplify = FALSE) {
  LL(full, simplify)
  x <- well_index(object, rownames(WELL_MAP))
  if (!is.character(x))
    x <- rownames(WELL_MAP)[x]
  ok <- is.custom <- custom_plate_is(plate)
  x <- matrix(x, length(x), length(plate), FALSE, list(x, ifelse(is.custom,
    custom_plate_normalize(plate), normalize_predefined_plate(plate))))
  ok[is.custom] <- vapply(colnames(x)[is.custom], custom_plate_exists, NA)
  ok[!is.custom] <- match(colnames(x)[!is.custom], colnames(WELL_MAP), 0L) > 0L
  x[, !ok] <- NA_character_
  if (full)
    for (i in which(ok))
      x[, i] <- map_well_names(x[, i], colnames(x)[i], in.parens = in.parens,
        max = max, brackets = brackets, clean = clean, word.wise = word.wise,
        paren.sep = paren.sep, downcase = downcase, rm.num = rm.num)
  if (simplify && ncol(x) == 1L)
    return(x[, 1L])
  class(x) <- "well_coords_map"
  x
}, sealed = SEALED)

setMethod("wells", "missing", function(object, ...) {
  wells(object = TRUE, ...)
}, sealed = SEALED)

#= listing wells

#' @rdname wells
#' @export
#'
setGeneric("listing")

setOldClass("well_coords_map")

setClass("well_coords_listing", contains = "print_easy")

setMethod("listing", "well_coords_map", function(x) {
  x <- x[!apply(is.na(x), 1L, all), , drop = FALSE]
  result <- structure(vector("list", ncol(x)), names = plate <- colnames(x))
  full <- ifelse(custom_plate_is(plate),
    mget(custom_plate_prepend_full(custom_plate_proper(plate)), MEMOIZED,
    "character", rep.int(list(NA_character_), length(plate))), PLATE_MAP[plate])
  for (i in seq_along(result))
    result[[i]] <- list(full[[i]], as.list(x[, i]))
  class(result) <- c("well_coords_listing", "print_easy")
  result
}, sealed = SEALED)

setMethod("listing", OPMD, function(x, as.groups,
    cutoff = opm_opt("min.mode"), downcase = TRUE, full = TRUE,
    in.parens = FALSE, html = FALSE, sep = " ", ..., exact = TRUE,
    strict = TRUE) {
  res <- to_sentence(discretized(object = x, full = full,
    in.parens = in.parens, downcase = downcase, ...), html)
  if (length(as.groups)) {
    res <- matrix(res, 1L, length(res), FALSE, list(NULL, names(res)))
    rownames(res) <- paste0(metadata(x, as.groups, exact, strict),
      collapse = L(sep))
    attr(res, "cutoff") <- L(cutoff)
    class(res) <- "OPMS_Listing"
  } else
    class(res) <- "OPMD_Listing"
  attr(res, "html") <- html
  res
}, sealed = SEALED)

setMethod("listing", OPMS, function(x, as.groups, cutoff = opm_opt("min.mode"),
    downcase = TRUE, full = TRUE, in.parens = FALSE, html = FALSE, sep = " ",
    ..., exact = TRUE, strict = TRUE) {
  add_stuff <- function(x, html, cutoff) {
    class(x) <- "OPMS_Listing"
    attr(x, "html") <- html
    attr(x, "cutoff") <- cutoff
    x
  }
  LL(cutoff, sep)
  if (!length(as.groups)) {
    res <- do.call(rbind, lapply(X = x@plates, FUN = listing, html = html,
      downcase = downcase, full = full, in.parens = in.parens,
      as.groups = NULL, ...))
    rownames(res) <- seq_len(nrow(res))
    return(add_stuff(res, html, cutoff))
  }
  res <- extract(object = x, subset = DISC_PARAM, as.groups = as.groups,
    sep = sep, exact = exact, strict = strict, downcase = downcase,
    full = full, in.parens = in.parens, dataframe = FALSE, as.labels = NULL,
    ...)
  res <- vapply(split.default(seq_len(nrow(res)), attr(res, "row.groups")),
    function(idx) to_sentence(reduce_to_mode.matrix(res[idx, , drop = FALSE],
      cutoff, TRUE), html), character(3L))
  add_stuff(t(res), html, cutoff)
}, sealed = SEALED)


################################################################################


#' Identify substrates or positions
#'
#' Identify the names of substrates as used in the stored plate annotations, or
#' identify the positions of substrates, i.e. the plate(s) and well(s) in which
#' they occur. Exact or error-tolerant matching can be used, as well as globbing
#' and regular-expression matching.
#'
#' @param object Query character vector or factor, when searching for positions
#'   alternatively a list, an S3 object of class \sQuote{substrate_match}, an
#'   \code{\link{OPM}} or an \code{\link{OPMS}} object.
#'
#' @param type Ignored if empty or \code{FALSE}. Otherwise, passed to
#'   \code{\link{plate_type}} for normalisation and then used to restrict the
#'   positions to those in that plate. Changes the output object to a vector;
#'   see below for details. In the case of \code{\link{OPMX}} objects, this can
#'   be set to \code{TRUE}, causing the use of the plate of \code{object}.
#' @param search Character scalar indicating the search mode. \describe{
#'   \item{exact}{Query names must exactly match (parts of) the well
#'   annotations.}
#'   \item{glob}{Shell globbing is used. See \code{\link{glob_to_regex}} for a
#'   description of globbing patterns.}
#'   \item{approx}{Approximate matching is used; the number or proportion of
#'   errors allowed is set using \code{max.dev}, and neither globbing or
#'   regular-expression matching is done in that case.}
#'   \item{regex}{Regular-expression matching is used.}
#'   \item{pmatch}{Uses \code{pmatch} from the \pkg{base} package.}
#'   }
#'   All matching is case-insensitive except for the \kbd{exact} and
#'   \kbd{pmatch} search modes.
#' @param max.dev Numeric scalar indicating the maximum allowed deviation. If <
#'   1, the proportion of characters that might deviate, otherwise their
#'   absolute number. It can also be a list; see the \sQuote{max.distance}
#'   argument of \code{agrep} in the \pkg{base} package for details. Has an
#'   effect only if \sQuote{approx} is chosen as search mode (see the
#'   \code{search} argument).
#' @param ... Optional arguments passed between the methods.
#' @export
#' @return
#'   \code{find_substrate} returns an S3 object of class
#'   \sQuote{substrate_match}; basically a list of character vectors (empty if
#'   nothing was found), with duplicates removed and the rest sorted. The names
#'   of the list correspond to \code{names}.
#'
#'   The \code{find_positions} character method returns a list of character
#'   matrices (empty if nothing was found), with one row per position found, the
#'   plate name in the first column and the well name in the second. The names
#'   of this list correspond to \code{names}. The \code{\link{OPM}} and
#'   \code{\link{OPMS}} methods do the same, using their own substrates. The
#'   list and \sQuote{substrate_match} methods return lists of such lists.
#'
#' @details When searching for positions, the query names must be written
#'   exactly as used in the stored plate annotations. To determine their
#'   spelling, use \code{find_substrate}. This spelling is not guaranteed
#'   to be stable between distinct \pkg{opm} releases.
#'
#' @seealso base::grep base::agrep
#' @family naming-functions
#' @keywords character utilities
#' @examples
#'
#' ## find_substrate()
#'
#' # Note that 'exact' search matches parts of the names, whereas globbing
#' # matches entire strings if there are no wildcards (which wouldn't make much
#' # sense)
#' (x <- find_substrate("D-Glucose", search = "exact"))
#' (y <- find_substrate("D-Glucose", search = "glob"))
#' stopifnot(length(x[[1]]) > length(y[[1]]))
#'
#' # 'pmatch' matching matches partially at the beginning and returns at most
#' # one match (the first one)
#' (y <- find_substrate("D-Glucose", search = "pmatch"))
#' stopifnot(length(x[[1]]) > length(y[[1]]))
#'
#' # Now allowing mismatches
#' (z <- find_substrate("D-Glucose", search = "approx"))
#' stopifnot(length(z[[1]]) > length(x[[1]]))
#'
#' # Factor method
#' (zz <- find_substrate(as.factor("D-Glucose"), search = "approx"))
#' stopifnot(identical(z, zz))
#'
#' ## find_positions()
#'
#' # Character method; compare correct and misspelled substrate name
#' (x <- find_positions(c("D-Glucose", "D-Gloucose")))
#' stopifnot(length(x[[1]]) > length(x[[2]]))
#'
#' # Factor method
#' (y <- find_positions(as.factor(c("D-Glucose", "D-Gloucose"))))
#' stopifnot(identical(y, x))
#'
#' # Restrict to  a certain plate
#' (x <- find_positions(c("D-Glucose", "D-Gloucose"), type = "Gen III"))
#' stopifnot(is.character(x), any(is.na(x)), !all(is.na(x)))
#'
#' # List method
#' x <- find_positions(find_substrate(c("D-Glucose", "D-Gloucose")))
#' x[[1]][1:3]
#' x[[2]]
#' stopifnot(length(x[[1]]) > length(x[[2]]))
#'
setGeneric("find_substrate",
  function(object, ...) standardGeneric("find_substrate"))

setMethod("find_substrate", "character", function(object,
    search = c("exact", "glob", "approx", "regex", "pmatch"), max.dev = 0.2) {
  su <- function(x) lapply(lapply(x, unique.default), sort.int)
  find_name <- function(patterns, ...) {
    su(lapply(X = patterns, FUN = grep, x = WELL_MAP[, , "name"], value = TRUE,
      useBytes = TRUE, ...))
  }
  find_approx <- function(pattern, ...) {
    su(lapply(X = pattern, FUN = agrep, x = WELL_MAP[, , "name"], value = TRUE,
      ignore.case = TRUE, useBytes = TRUE, ...))
  }
  find_partial <- function(pattern) {
    # next step necessary because multiple <partial> matches are never allowed
    table <- unique.default(WELL_MAP[, , "name"])
    found <- table[pmatch(pattern, table, NA_integer_, TRUE)]
    names(found) <- pattern
    lapply(lapply(as.list(found), na.exclude), sort.int)
  }
  result <- case(match.arg(search),
    exact = find_name(object, fixed = TRUE),
    glob = find_name(structure(glob_to_regex(object), names = object),
      ignore.case = TRUE, perl = TRUE),
    regex = find_name(object, ignore.case = TRUE, perl = TRUE),
    approx = find_approx(object, max.distance = max.dev),
    pmatch = find_partial(object)
  )
  names(result) <- object
  class(result) <- c("substrate_match", "print_easy")
  result
}, sealed = SEALED)

#= find_positions find_substrate

setOldClass("substrate_match")

#' @rdname find_substrate
#' @export
#'
setGeneric("find_positions",
  function(object, ...) standardGeneric("find_positions"))

setMethod("find_positions", "character", function(object, type = NULL, ...) {
  if (length(type) && !identical(type, FALSE)) {
    x <- WELL_MAP[, plate_type(type)[1L], "name"]
    return(structure(names(x)[match(object, x)], names = object))
  }
  plates <- colnames(WELL_MAP)
  sapply(object, FUN = function(name) {
    result <- which(WELL_MAP[, , "name"] == name, arr.ind = TRUE)
    matrix(c(plates[result[, 2L]], rownames(result)), ncol = 2L,
      dimnames = list(NULL, RESERVED_NAMES[c("plate", "well")]))
  }, simplify = FALSE)
}, sealed = SEALED)

setMethod("find_positions", "substrate_match", function(object, ...) {
  rapply(object, f = find_positions, "character", how = "list", ...)
}, sealed = SEALED)

setMethod("find_positions", "list", function(object, ...) {
  rapply(object, f = find_positions, classes = c("character", "factor"),
    how = "list", ...)
}, sealed = SEALED)

setMethod("find_positions", OPM, function(object, type = NULL, ...) {
  object <- wells(object, full = TRUE, in.parens = FALSE)
  if (isTRUE(type))
    structure(names(object), names = object)
  else
    find_positions(object, ...)
}, sealed = SEALED)


################################################################################


#' Provide information on substrates
#'
#' Return information on substrates such as their \acronym{CAS} number or
#' other database ID or convert substrate names.
#'
#' @param object Query character vector, factor or list, S3 object of class
#'   \sQuote{substrate_match}, \code{\link{OPM}}, \code{\link{OPMS}} or
#'   \code{\link{MOPMX}} object.
#' @param what Character scalar indicating which kind of information to output.
#'   \describe{
#'     \item{all}{Create object of S3 class \sQuote{substrate_data} containing
#'     all available information and useful for display.}
#'     \item{cas}{\acronym{CAS} registry number, optionally expanded to an
#'     \acronym{URL}.}
#'     \item{chebi}{\acronym{ChEBI} database ID, optionally expanded to an
#'     \acronym{URL}.}
#'     \item{concentration}{Attempt to extract concentration information (as
#'     used in \pkg{opm} substrate names) from \code{object}. Return \code{NA}
#'     wherever this fails.}
#'     \item{downcase}{Substrate name converted to lower case, protecting
#'     one-letter specifiers, acronyms and chemical symbols, and translating
#'     relevant characters from the Greek alphabet.}
#'     \item{drug}{\acronym{KEGG} drug database ID, optionally expanded to an
#'     \acronym{URL}.}
#'     \item{greek}{Substrate name after translation of relevant characters to
#'     Greek letters.}
#'     \item{html}{Like \kbd{greek}, but using \acronym{HTML} tags, and also
#'     converting other parts of compound names that require special
#'     formatting.}
#'     \item{kegg}{\acronym{KEGG} compound database ID, optionally expanded to
#'     an \acronym{URL}.}
#'     \item{mesh}{\acronym{MeSH} database name (useful for conducting
#'     \acronym{PubMed} searches), optionally expanded to an \acronym{URL}.}
#'     \item{metacyc}{\acronym{MetaCyc} database ID, optionally expanded to an
#'     \acronym{URL}.}
#'     \item{peptide}{List of character vectors representing amino acids in
#'     three-letter code, in order, contained in the substrate if it is a
#'     peptide. Empty character vectors are returned for non-peptide substrates.
#'     Amino acids without \sQuote{L} or \sQuote{D} annotation are assumed to be
#'     in \sQuote{L} conformation, i.e. \sQuote{L-} is removed from the
#'     beginning of the amino acid codes.}
#'     \item{peptide2}{Like \code{peptide}, but without removal of \sQuote{L-}
#'     from the beginning of the amino acid codes.}
#'   }
#'   See the references for information on the databases.
#' @param browse Numeric scalar. If non-zero, an \acronym{URL} is generated from
#'   each \acronym{ID}. If positive, this number of \acronym{URL}s (counted from
#'   the beginning) is also opened in the default web browser; if negative, the
#'   \acronym{URL}s are only returned. It is an error to try this with those
#'   values of \code{what} that do not yield an \acronym{ID}.
#' @param download Logical scalar indicating whether, using the available IDs,
#'   substrate information should be queried from the according web services and
#'   returned in customised objects. Note that this is unavailable for most
#'   values of \code{what}. At the moment only \kbd{kegg} and \kbd{drug} can be
#'   queried for if the \pkg{KEGGREST} package is available. This would yield S3
#'   objects of the class \code{kegg_compounds}.
#' @param ... Optional other arguments passed between the methods.
#' @export
#' @return The character method returns a character vector with \code{object}
#'   used as names and either a matched entry or \code{NA} as value. Only if
#'   \code{what} is set to \sQuote{peptide} a named list is returned instead.
#'   The factor method works like the character method, whereas the list method
#'   traverses a list and calls \code{substrate_info} on suitable elements,
#'   leaving others unchanged. The \code{\link{OPM}} and \code{\link{OPMS}}
#'   methods work like the character method, using their own substrates.
#'
#'   Depending on the \code{browse} argument, the returned \acronym{ID}s might
#'   have been converted to \acronym{URL}s, and as a side effect tabs in the
#'   default web browser might have been opened. For suitable values of
#'   \code{what}, setting \code{download} to \code{TRUE} yielded special objects
#'   as described above.
#'
#'   The \code{\link{MOPMX}} method yield a list with one element of one of the
#'   kinds described above per element of \code{object}.
#'
#' @details The query names must be written exactly as used in the stored plate
#'   annotations. To determine their spelling, use \code{\link{find_substrate}}.
#'   Each spelling might include a concentration indicator, but the same
#'   underlying substrate name yielded the same \acronym{ID} irrespective of the
#'   concentration.
#'
#'   Note that the information is only partially complete, depending on the well
#'   and the database. While it is possible to link almost all substrates to,
#'   say, \acronym{CAS} numbers, they are not necessarily contained in the other
#'   databases. Thanks to the work of the \acronym{ChEBI} staff, which is
#'   gratefully acknowledged, \acronym{ChEBI} information is complete as far as
#'   possible (large molecules such as proteins or other polymers are not
#'   covered by \acronym{ChEBI}).
#'
#'   For some wells, even a main substrate cannot be identified, causing all
#'   its \acronym{ID}s to be missing. This holds for all control wells, for all
#'   wells that contain a mixture of (usually two) substrates, and for all wells
#'   that are only specified by a certain pH.
#'
#'   The generated \acronym{URL}s should provide plenty of information
#'   on the respective substrate. In the case of \acronym{ChEBI}, \acronym{KEGG}
#'   and \acronym{MetaCyc}, much information is directly displayed on the page
#'   itself, whereas the chosen \acronym{CAS} site contains a number of links
#'   providing additional chemical details. The \acronym{MeSH} web pages
#'   directly link to according \acronym{PubMed} searches.
#' @family naming-functions
#' @keywords utilities
#' @seealso utils::browseURL
#' @references Bochner, B. R., pers. comm.
#' @references \url{http://www.cas.org/content/chemical-substances/faqs}
#' @references \url{http://www.genome.jp/kegg/}
#' @references Kanehisa, M., Goto, S., Furumichi, M., Tanabe, M., and Hirakawa,
#'   M. 2010 KEGG for representation and analysis of molecular networks
#'   involving diseases and drugs. \emph{Nucleic Acids Research} \strong{38}:
#'   D355--D360.
#' @references \url{http://metacyc.org/}
#' @references Caspi, R., Altman, T., Dreher, K., Fulcher, C.A., Subhraveti,
#'   P., Keseler, I.M., Kothari, A., Krummenacker, M., Latendresse, M.,
#'   Mueller, L.A., Ong, Q., Paley, S., Pujar, A., Shearer, A.G., Travers, M.,
#'   Weerasinghe, D., Zhang, P., Karp, P.D. 2012 The MetaCyc database of
#'   metabolic pathways and enzymes and the BioCyc collection of pathway/genome
#'   databases. \emph{Nucleic Acids Research} \strong{40}: D742--D753.
#' @references \url{http://www.ncbi.nlm.nih.gov/mesh}
#' @references Coletti, M.H., Bleich, H.L 2001 Medical subject headings used to
#'   search the biomedical literature. \emph{Journal of the American Medical
#'   Informatics Association} \strong{8}: 317--323.
#' @references \url{http://www.ebi.ac.uk/chebi/}
#' @references Hastings, J., de Matos, P., Dekker, A., Ennis, M., Harsha, B.,
#'   Kale, N., Muthukrishnan, V., Owen, G., Turner, S., Williams, M.,
#'   Steinbeck, C. 2013 The ChEBI reference database and ontology for
#'   biologically relevant chemistry: enhancements for 2013. \emph{Nucleic Acids
#'   Research} \strong{41}: D456--D463.
#' @examples
#'
#' # Character method; compare correct and misspelled substrate name
#' (x <- substrate_info(c("D-Glucose", "D-Gloucose")))
#' stopifnot(any(is.na(x)), !all(is.na(x)))
#' stopifnot(identical(x, # Factor method yields same result
#'   substrate_info(as.factor(c("D-Glucose", "D-Gloucose")))))
#'
#' # Now with generation of URLs
#' (y <- substrate_info(c("D-Glucose", "D-Gloucose"), browse = -1))
#' stopifnot(is.na(y) | nchar(y) > nchar(x))
#' # NA remains NA (and the function would not try to open it in the browser)
#'
#' # Character method, safe conversion to lower case
#' (x <- substrate_info(c("a-D-Glucose", "a-D-Gloucose"), "downcase"))
#' stopifnot(nchar(x) > nchar(c("a-D-Glucose", "a-D-Gloucose")))
#' # note the protection of 'D' and the conversion of 'a'
#' # whether or not substrate names are known does not matter here
#'
#' # Peptide extraction (note treatment of non-standard amino acids)
#' (x <- substrate_info(c("Ala-b-Ala-D-Glu", "Glucose", "Trp-Val"), "peptide"))
#' stopifnot(is.list(x), sapply(x, length) == c(3, 0, 2))
#'
#' # List method
#' (x <- substrate_info(find_substrate(c("D-Glucose", "D-Gloucose"))))
#' stopifnot(length(x[[1]]) > length(x[[2]]))
#'
#' # OPM and OPMS methods
#' (x <- substrate_info(vaas_1[, 1:3], "all"))
#' stopifnot(inherits(x, "substrate_data"))
#' stopifnot(identical(x, substrate_info(vaas_4[, , 1:3], "all")))
#' \dontrun{
#'
#'   # this would open up to 96 tabs in your browser...
#'   substrate_info(vaas_4, "kegg", browse = 100)
#' }
#'
setGeneric("substrate_info",
  function(object, ...) standardGeneric("substrate_info"))

setMethod("substrate_info", "character", function(object,
    what = c("cas", "kegg", "drug", "metacyc", "chebi", "mesh", "downcase",
      "greek", "concentration", "html", "peptide", "peptide2", "all"),
    browse = 0L, download = FALSE, ...) {

  find_substrate_id <- function(x) {
    result <- WELL_MAP[, , "substrate_id"][match(x, WELL_MAP[, , "name"])]
    structure(as.integer(result), names = x)
  }

  create_url <- function(x, how) {
    url_base <- c(
      kegg = "http://www.genome.jp/dbget-bin/www_bget?cpd:",
      drug = "http://www.genome.jp/dbget-bin/www_bget?dr:",
      chebi = "http://www.ebi.ac.uk/chebi/searchId.do?chebiId=CHEBI:",
      metacyc = "http://biocyc.org/META/NEW-IMAGE?type=COMPOUND&object=",
      cas = "http://chem.sis.nlm.nih.gov/chemidplus/direct.jsp?regno=",
      mesh = "http://www.ncbi.nlm.nih.gov/mesh/"
    )
    base <- url_base[match.arg(how, names(url_base))]
    x <- sub("^(CAS\\s+|CHEBI:)", "", x, TRUE, TRUE)
    ifelse(is.na(x), NA_character_, paste0(base, vapply(x, URLencode, "")))
  }

  map_words <- function(x, fun, ...) {
    y <- strsplit(x, "\\w+", FALSE, TRUE)
    x <- strsplit(x, "\\W+", FALSE, TRUE)
    bad <- !vapply(x, function(value) nzchar(value[1L]), NA)
    x[bad] <- lapply(x[bad], `[`, i = -1L)
    bad <- vapply(x, length, 0L) < vapply(y, length, 0L)
    x[bad] <- lapply(x[bad], function(value) c(value, ""))
    x <- lapply(X = x, FUN = fun, ...) # fun() must keep the length!
    mapply(paste0, y, x, MoreArgs = list(collapse = ""))
  }

  expand_greek_letters <- function(x) {
    map_words(x, fun = map_values, mapping = GREEK_LETTERS)
  }

  compound_name_to_html <- function(x) {
    x <- gsub("'", "&prime;", safe_labels(x, "html"), FALSE, FALSE, TRUE)
    map_words(x, fun = map_values, mapping = COMPOUND_NAME_HTML_MAP)
  }

  safe_downcase <- function(x) {
    good_case <- function(x) {
      bad <- nchar(x) > 1L # avoid changing acronyms and chemical elements
      bad[bad] <- !grepl("^(pH|[a-z]?[A-Z][A-Z]+|([A-Z][a-z]?\\d*)+)$", x[bad],
        FALSE, TRUE)
      x[bad] <- tolower(x[bad])
      x
    }
    map_words(x, function(y) map_values(good_case(y), GREEK_LETTERS))
  }

  extract_concentration <- function(x) {
    in.parens <- grepl(SUBSTRATE_PATTERN[["either"]], x, FALSE, TRUE)
    x <- ifelse(in.parens, substr(x, 1L, nchar(x) - 1L), x)
    m <- regexpr("(?<=#)\\s*\\d+\\s*$", x, FALSE, TRUE)
    ## The following code is currently not in use because the only plate to
    ## which it is applicable (PM09) does not show regularity anyway. Conversion
    ## to integer would also be problematic because contractions such as 5.5 or
    ## 6.5 are present.
    #if (all(m < 0L)) {
    #  x <- ifelse(in.parens, substr(x, 6L, nchar(x)), x)
    #  m <- regexpr("^(?:\\d+(?:\\.\\d+)?)(?=%|mM)", x, FALSE, TRUE)
    #}
    as.integer(substr(x, m, m + attr(m, "match.length") - 1L))
  }

  parse_peptide <- function(x, remove.L) {
    recognize_full_names <- function(x) {
      m <- regexpr("^(?:[A-Za-z][,-])*[A-Za-z]-", x, FALSE, TRUE)
      result <- AMINO_ACIDS[substr(x, m + attr(m, "match.length"), nchar(x))]
      ok <- !is.na(result)
      prefix <- m > 0L & ok
      m <- substr(x, m, m + attr(m, "match.length") - 1L)
      result[prefix] <- paste0(m[prefix], result[prefix])
      result <- as.list(result)
      result[!ok] <- list(character())
      result
    }
    result <- structure(vector("list", length(x)), names = x)
    x <- remove_concentration(x)
    pat <- "(([A-Za-z][,-])*[A-Za-z]-)?[A-Z][a-z]{2}"
    pat <- sprintf("^%s(-%s)*$", pat, pat)
    ok <- grepl(pat, x, FALSE, TRUE)
    result[ok] <- strsplit(x[ok], "(?<!\\b\\w)-", FALSE, TRUE)
    result[!ok] <- recognize_full_names(x[!ok])
    if (remove.L)
      result <- lapply(result, sub, pattern = "^L-", replacement = "",
        ignore.case = FALSE, perl = TRUE)
    result
  }

  all_information <- function(x) {
    result <- SUBSTRATE_INFO[find_substrate_id(x), , drop = FALSE]
    colnames(result) <- map_values(colnames(result),
      c(METACYC = "MetaCyc", MESH = "MeSH", CHEBI = "ChEBI",
        KEGG = "KEGG compound", DRUG = "KEGG drug"))
    result <- split.data.frame(result, seq_len(nrow(result)))
    result <- lapply(result, function(y) y[, !is.na(y), drop = TRUE])
    class(result) <- c("substrate_data", "print_easy")
    result
  }

  result <- case(what <- match.arg(what),
    all = all_information(object),
    chebi =, drug =, kegg =, metacyc =, mesh =,
    cas = SUBSTRATE_INFO[find_substrate_id(object), toupper(what)],
    concentration = extract_concentration(object),
    downcase = safe_downcase(object),
    greek = expand_greek_letters(object),
    html = compound_name_to_html(object),
    peptide = parse_peptide(object, TRUE),
    peptide2 = parse_peptide(object, FALSE)
  )
  browse <- must(as.integer(L(browse)))
  if (browse != 0L) {
    result <- create_url(result, what)
    if (browse > 0L)
      lapply(head(result[!is.na(result)], browse), browseURL)
  }
  names(result) <- object
  if (L(download))
    result <- web_query(result, what)
  result
}, sealed = SEALED)

setMethod("substrate_info", "substrate_match", function(object, ...) {
  rapply(object = object, f = substrate_info, classes = "character",
    how = "replace", ...)
}, sealed = SEALED)

setMethod("substrate_info", "list", function(object, ...) {
  rapply(object = object, f = substrate_info, how = "replace",
    classes = c("character", "factor"), ...)
}, sealed = SEALED)

setMethod("substrate_info", OPM, function(object, ...) {
  substrate_info(wells(object, full = TRUE, in.parens = FALSE), ...)
}, sealed = SEALED)


################################################################################


#' Conduct a web query
#'
#' Search via a web service for substrate information, given the IDs.
#'
#' @param ids Vector of substrate IDs.
#' @param what Character scalar indicating the web service to use.
#' @return Dedicated kind of S3 object, depending on \code{what}.
#' @details \acronym{KEGG} queries need the \pkg{KEGGREST} package.
#' @seealso substrate_info
#' @keywords internal
#'
web_query <- function(ids, what = c("kegg", "drug")) {
  get_kegg <- function(x, prepend) {
    compound_object <- function(x) {
      pos <- match(c("EXACT_MASS", "MOL_WEIGHT"), names(x), 0L)
      for (p in pos[pos > 0L])
        x[[p]] <- as.numeric(x[[p]])
      class(x) <- c("kegg_compound", "print_easy")
      x
    }
    chunks <- function(x, n) split.default(x,
      rep(seq_len(ceiling(length(x) / n)), each = n)[seq_along(x)])
    run_keggrest <- function(x, prepend) {
      result <- lapply(chunks(paste0(prepend, x), 10), KEGGREST::keggGet)
      result <- lapply(unlist(result, FALSE), compound_object)
      names(result) <- vapply(result, `[[`, "", "ENTRY")
      found <- match(names(result), x, 0L)
      if (!all(found > 0L))
        stop("KEGG request yielded entries that do not match the query")
      structure(result[found], names = x)
    }
    prepend <- paste0(match.arg(prepend, c("cpd", "drug")), ":")
    got <- get_and_remember(x = x, prefix = "KEGG.", getfun = run_keggrest,
      default = compound_object(list()), prepend = prepend)
    structure(got, names = names(x), class = c("kegg_compounds", "print_easy"))
  }
  case(match.arg(what),
    kegg = get_kegg(ids, "cpd"),
    drug = get_kegg(ids, "drug")
  )
}


################################################################################


#' Collect information from KEGG objects
#'
#' @param x Object of class \sQuote{kegg_compounds}.
#' @param what Character vector indicating which information to include.
#'   Multiple values are possible; the default is to collect everything.
#' @param missing.na Logical scalar indicating whether missing compounds should
#'   be coded as \code{NA} (instead of zero).
#' @return Numeric matrix.
#' @name collect
#' @keywords internal
#'
NULL

#' @rdname collect
#' @method collect kegg_compounds
#'
collect.kegg_compounds <- function(x,
    what = c("pathway", "brite", "activity", "exact_mass"),
    missing.na = TRUE, ...) {
  partial_matrix <- function(name, x) {
    convert <- list(
      ACTIVITY = function(x) {
        # notes in brackets make entries more specific; we use both variants
        unique.default(c(x, sub("\\s+\\[.*", "", x, FALSE, TRUE)))
      },
      BRITE = function(x) {
        if (!length(x))
          return(character())
        # remove the starting points of the classifications (which are just
        # their names) and the end points (the substrates themselves)
        m <- attr(regexpr("^\\s+", x, FALSE, TRUE), "match.length")
        x <- x[!(m < 0L | c(m[-1L] < m[-length(m)], TRUE))]
        gsub("\\s+", " ", sub("^\\s+", "", x, FALSE, TRUE), FALSE, TRUE)
      },
      PATHWAY = names,
      EXACT_MASS = function(x) if (is.null(x))
        NA_real_
      else
        x
    )
    result <- lapply(lapply(x, `[[`, name), convert[[name]])
    if (name == "EXACT_MASS")
      matrix(unlist(result), ncol = 1L, dimnames = list(NULL, tolower(name)))
    else
      pkgutils::collect(result, "occurrences")
  }
  what <- toupper(match.arg(what, several.ok = TRUE))
  result <- do.call(cbind, lapply(what, partial_matrix, x))
  if (L(missing.na))
    result[!vapply(x, length, 0L), ] <- as(NA, typeof(result))
  result
}


################################################################################
#
# Automatically generated factor methods
#


lapply(c(
    #+
    find_substrate,
    find_positions,
    substrate_info
    #-
  ), FUN = function(func_) {
  setMethod(func_, "factor", function(object, ...) {
    func_(as.character(object), ...)
  }, sealed = SEALED)
})


################################################################################
#
# Automatically generated OPMS methods
#

# Applying OPM methods with function(object, ...) signature to the 1st plate
# only.
#
lapply(c(
    #+
    find_positions,
    substrate_info,
    wells,
    plate_type
    #-
  ), FUN = function(func_) {
  setMethod(func_, OPMS, function(object, ...) {
    func_(object@plates[[1L]], ...)
  }, sealed = SEALED)
})


# MOPMX methods with function(object, ...) signature that should not be
# simplified.
#
lapply(c(
    #+
    find_positions,
    substrate_info,
    wells
    #-
  ), FUN = function(func_) {
  setMethod(func_, MOPMX, function(object, ...) {
    lapply(object@.Data, FUN = func_, ...)
  }, sealed = SEALED)
})

