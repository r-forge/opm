

\documentclass[nojss]{jss}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% GENERAL HINTS: STYLE OF THIS DOCUMENT
%
% See the according section in the Rnw file for the main tutorial!!!
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% These commands do nothing. They are used for a logical annotation of text,
% causing the spellchecker to ignore its content.
%
\def\Surname{}
\def\German{}

% Acronyms
%
\usepackage{acronym}
\acrodef{CSV}{Comma-Separated Values}
\acrodef{DM}{Dry Mass}
\acrodef{DSM}{\German{Deutsche Sammlung von Mikroorganismen}}
\acrodef{DSMZ}{\German{Deutsche Sammlung von Mikroorganismen und Zellkulturen}}
\acrodef{FM}{Fresh Mass}
\acrodef{PM}{Phenotype Microarray}

%% Add Revision Control System (RCS) Markups
\usepackage{ulem}      % use this for sout
\usepackage{hyperref}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{enumitem}
%\usepackage{fancyvrb}
\normalem              % set \emph to \textit again
% Additions (in blue)
\def\rcsadd#1{{\color{blue}#1}}
% Deletions (in red)
\def\rcsdel#1{{\color{red}\sout{#1}}}
% Yellow box (few words)
\def\rcsmark#1{\colorbox{yellow}{#1}}
%Yellow box (paragraph)
\def\rcscom#1{\noindent\newline\vspace*{0.5cm}\colorbox{yellow}{\parbox{\textwidth}{#1}}\vspace*{0.5cm}}


%% overwrite JSS definition of subsubsections
%% e.g., use numbering
\renewcommand{\jsssubsubsec}[2][default]{\vskip \preSskip%
  \pdfbookmark[3]{#1}{Subsubsection.\thesubsubsection.#1}%
  \refstepcounter{subsubsection}%
  {\large \thesubsubsection. #2} \nopagebreak
  \vskip \postSskip \nopagebreak}

%% overwrite JSS definitions of code sections
%% (make font smaller)
\DefineVerbatimEnvironment{Sinput}{Verbatim}{fontshape=sl, fontsize=\small}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{Scode}{Verbatim}{fontshape=sl, fontsize=\small}

\DefineVerbatimEnvironment{Code}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{CodeInput}{Verbatim}{fontshape=sl, fontsize=\small}
\DefineVerbatimEnvironment{CodeOutput}{Verbatim}{fontsize=\small}



%% needed for CRAN checking
%\VignetteIndexEntry{Substrate information in opm}


% authors, first page
\author{Lea A.I. \Surname{Vaas}\\Leibniz Institute \acs{DSMZ} \And
        Markus \Surname{G\"{o}ker}\\Leibniz Institute \acs{DSMZ}}


% title, first page
\title{Analysing growth curves and other user-defined plates in \pkg{opm}}


% authors, header on every 2nd page
\Plainauthor{L.A.I. Vaas, M. G\"{o}ker}


% main title, first page
\Plaintitle{Analysing growth curves and other user-defined plates in opm}


% short title, header on every 2nd page
\Shorttitle{User-defined plates in \pkg{opm} (\today)}


\Abstract{
This is tutorial about the analysis of growth curves and other user defined kinetics with the \pkg{opm} package in the version of \today{}.
It is explained how any kinds of growth or respiration measurements can be input into \pkg{opm}.
We also show how \ac{PM} data with user-defined plate types can be analysed.
Analysing such data visually and statistically requires in some cases adaptations of function arguments whose defaults are targeting \ac{PM} data.
All these practically relevant issues are explained in detail.
}

\Keywords{Growth Kinetics}

\Plainkeywords{respiration kinetics, pathways, CAS, MeSH, ChEBI, MetaCyc, KEGG, pathview}

\Address{
  Markus \Surname{G\"{o}ker}\\
  Leibniz Institute \acs{DSMZ} -- German Collection of Microorganisms and Cell Cultures\\
  \German{Braunschweig}\\
  \\
  Telephone: +49/531-2616-272\\
  Fax: +49/531-2616-237\\
  E-mail: \email{markus.goeker@dsmz.de}\\
  URL: \url{www.dsmz.de}\\
}


%% this must be included if Sweave is used (with % symbols):
%% need no \usepackage{Sweave.sty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}
% NOTE: Rstudio might insert a line '\SweaveOpts{concordance=TRUE}' after '\begin{document}', which is removed again by the build script, as it causes warning messages during R CMD check.
% So please don't try to rescue that line, and don't rely on it being there.


%% so far adding a TOC proved unsuccessful -- apparently the JSS style doesn't allow for a TOC
%\tableofcontents
%\newpage
\acresetall

\section{Introduction}\label{introduction}

A detailed description of the OmniLog\textregistered \ \ac{PM} system, its measuring procedure and data characteristics are found in the vignette ``\pkg{opm}: An R Package for Analysing OmniLog\textregistered \ Phenotype Microarray Data'' (called ``main tutorial'' in the following).
How substrate information stored within \pkg{opm} can be accessed and used for advanced visual and statistical analyses is explained in the vignette ``Working with substrate information in \pkg{opm}'' (called ``substrate tutorial'' in the following).
The description of the methods below presupposes that the user is familiar with the usage of \pkg{opm} and has studied the main tutorial, the substrate tutorial as well as the entries of the \pkg{opm} manual relevant to her or his research.
Especially the concepts behind, and the methods available for, the different classes of \pkg{opm} objects should be known before starting with this tutorial.

In addition to visual inspection or statistical comparative analyses of \ac{PM} data, as described in the main tutorial and the substrate tutorial, users might be interested in analysing data other than \ac{PM} data, or analysing \ac{PM} with user-defined plate types.
To work with user-defined \ac{PM} plates only requires registering these plates, i.e. storing a mapping from well coordinates to substrate names, and optionally also a full, descriptive name for the plate.
The analysis of data other than \ac{PM} data, such as growth curves, additionally requires inputting these data and converting them to \proglang{OPMX} objects.
Moreover, some defaults of the plotting functions are only suitable for \ac{PM} data.
Hence, the functions should be called slightly distinctly.

Besides these slight restrictions, which are illustrated with examples below, non-\ac{PM} data can be analysed with \pkg{opm} almost like \ac{PM} data.


\section{Preparation}\label{preparation}

<<label=chunk-setup, echo=FALSE>>=
options(width = 90)
options(prompt = "R> ")
options(continue = "   ")
options(useFancyQuotes = FALSE)
library("methods")
@

As usual, \pkg{opm} must be loaded before any analysis can begin:

<<label=load-library>>=
if ("package:opm" %in% search())
  detach("package:opm", unload = TRUE)
library("opm")
@

\section{Growth-curve data input}\label{data-input}

\subsection{User-entered data frames}\label{user-entered-input-data}

In the following we will use the growth-measurements data set from \citet{ijms140715141} as exemplar.
These data have been entered by hand and then input into \proglang{R} with one of the functions for reading \ac{CSV}, yielding a data frame, which comes with \pkg{opm}:

<<label=load-potatoes>>=
data("potato")
head(potato)
@

For details on this data set, enter \code{?potato} at the \proglang{R} prompt.
The measurements are in ``long'' format and must be reshaped using the eponymous function into ``wide'' format.
We do this separately for the \ac{DM} and \ac{FM} measurements within the data set:

<<label=reshape-potatoes>>=
# order the treatment
potato$Treatment <- factor(potato$Treatment,
  levels = c("Control", "0.16M NaCl", "0.32M NaCl", "0.5M Sorbitol"),
  ordered = TRUE)
# reshape
potato.fm <- reshape(potato, v.names = "FM", drop = "DM", direction = "wide",
  idvar = c("Genotype", "Treatment", "Replicate"), timevar = "Time")
potato.dm <- reshape(potato, v.names = "DM", drop = "FM", direction = "wide",
  idvar = c("Genotype", "Treatment", "Replicate"), timevar = "Time")
@

``long'' format means, that each measurement is stored in a separate record with one entry per line (see above).
Thus for each data point the entries in ``Genotype'', ``Treatment'' and ``Time'' have to be repeated, resulting in a data frame with dimensions of \Sexpr{dim(potato)[1]} rows in \Sexpr{dim(potato)[2]} columns.

With the \code{reshape} it is possible to rearrange the data set in a form, where the columns ``Genotype'', ``Treatment'' and ``Replicate'' are kept and columns ``Time'' and either ``\ac{FM}'', or ``\ac{DM}'' respectively, are merged resulting in 9 columns representing the measurement times (see below the first six rows of object \code{potato.fm}).

<<label=potato-reshaped>>=
head(potato.fm)
@

Thus the dimension of the data object dwindled to \Sexpr{dim(potato.fm)[1]} rows in \Sexpr{dim(potato.fm)[2]} columns.

Now the data are in the right arrangement for the next step, the conversion into \proglang{OPMX} or \proglang{MOPMX} objects.

The main function for converting user-defined data frames to \proglang{OPMX} or \proglang{MOPMX} objects is \code{opmx}, which can directly be applied to the objects created in the last step.
This works because the ``horizontal'' input format of \code{opmx} corresponds to the ``wide'' format of \code{reshape}.

<<label=potatoes-to-opmx>>=
potato.fm <- opmx(potato.fm, position = c("Genotype", "Replicate"),
  well = "Treatment", prefix = "FM.",
  full.name = c(fm = "Growth experiment, fresh mass"))
potato.dm <- opmx(potato.dm, position = c("Genotype", "Replicate"),
  well = "Treatment", prefix = "DM.",
  full.name = c(dm = "Growth experiment, dry mass"))
@

The data frame contains all substrate information (in the ``Treatment'' column).
Hence, \pkg{opm} registers the mapping from well coordinates to substrate names on the fly.
The plate type must be provided, however.
As it is not within the data frame, the short name of the plate type is taken from the \code{full.name} argument, whose main purpose is to enter the full, descriptive name of the plate type.
``Genotype'' and ``Replicate'' go to the metadata of the resulting object and together identify each plate.
In the case of \ac{PM} data, this is done using the position of the plate within the OmniLog\textregistered \ reader.
Thus the relevant argument here is \code{position}, which must be supplied unless there is a column of that name.
The \code{prefix} argument helps identifying the columns with measurements over time.

The registered plate type can be queried as follows:

<<label=show-potato-plate-type>>=
plate_type(TRUE) # shows all existing user-defined plates
listing(wells(plate = c("CUSTOM:FM", "CUSTOM:DM")))
@

Note the prefix ``CUSTOM:'', which is used to distinguish user-defined plate type from those that come with \pkg{opm}.
Please keep in mind, that the definition of plate types is only available in the current \proglang{R} session. The definitions will be lost, when the session is terminated. Saving and/or loading of a session can be managed by the functionality provided by \pkg{session} \citep{warnes2012}.

The object resulting from \code{listing} can be output with \code{to_yaml} or \code{saveRDS} for externally storing plate types in files.

With the  \code{potato.dm} and \code{potato.fm} objects the user can now follow the work flow as it is envisaged for processing of usual \ac{PM} data. Please continue in Section~\ref{visualisation} and following for plotting and statistical analysis of the estimated curve parameters.

\subsection{Direct registration of plate types}\label{overview-register-plate-type}

An example input file comes along with \pkg{opm}, providing growth curve data which were derived from an growth challenging experiment with two \textit{Escherichia coli} strains (\ac{DSM} 18039 $=$ K12 and the type strain \ac{DSM} 30083\textsuperscript{T}) on increasing Glucose concentrations.
Each strain-Glucose-concentration combination was repeated twice on the plate.
Thus, it will first be shown, how to prepare a plate map, register it as a new plate type and import the data with subsequently conversion of the data into an \proglang{OPMX} or \proglang{MOPMX} object.
Afterwards it will be shown how to use the \code{split} function in order to split the objects to provide objects representing the repetitions.

\subsubsection{Set up a plate map and register plate types}\label{register-plate-type}
Provided by \code{register_plate}, \pkg{opm} brings several options for setting up a user defined plate layout.
This function works with both customised \ac{PM} plates run, as well as plates of other well design and formats used for measurement of for example growth in a conventional plate reader.

For small set ups it might be feasible to type the substrate allocation manually into a character string, as it is done in the following.
%\rcsmark{TODO.}
%TODO Lea: register the well map and the full name of the TECAN plate used below
<<label=register_plate>>=
register_plate(growth = c(A01 = "negative control #1", A02 = "10mM Glucose #1",
A03 = "20mM Glucose #1", A04 = "50mM Glucose #1", A05 = "100mM Glucose #1",
A06 = "200mM Glucose #1",
B01 = "negative control #2", B02 = "10mM Glucose #2",
B03 = "20mM Glucose #2", B04 = "50mM Glucose #2", B05 = "100mM Glucose #2",
B06 = "200mM Glucose #2",
C01 = "negative control #3", C02 = "10mM Glucose #3",
C03 = "20mM Glucose #3", C04 = "50mM Glucose #3", C05 = "100mM Glucose #3",
C06 = "200mM Glucose #3",
D01 = "negative control #4", D02 = "10mM Glucose #4",
D03 = "20mM Glucose #4", D04 = "50mM Glucose #4", D05 = "100mM Glucose #4",
D06 = "200mM Glucose #4"),
growth = "growth")
#listing(wells(plate = "custom:growth"))
@

However, this procedure is error prone and not efficient when dealing with sets containing more than a few wells.
Alternatively, a user-designed plate can also be registered with a plate map given as matrix.
The matrix then directly represents the allocation of the used substrates on the plate.

First, the matrix for the plate map has to be stated as follows.
<<label=setup_plate_map_matrix>>=
growth <- matrix(rep(c("negative control", "10mM Glucose", "20mM Glucose",
  "50mM Glucose", "100mM Glucose", "200mM Glucose"), each = 4),
  nrow = 4, ncol = 6)
rownames(growth) <- LETTERS[1:4]
colnames(growth) <- 1:6
@

The next step is to register the layout as a new plate type.
Here it is named ``growth''.

<<label=register_plate_matrix>>=
growth.reg <- register_plate(growth = growth)
# listing(wells(plate = "CUSTOM:GROWTH"))
@

Alternatively, the input for \code{register_plate} can also be a data frame.

<<label=setup_plate_map_dataframe>>=
growth.dat <- as.data.frame(growth)
growth.dat.reg <- register_plate(growth.dat = growth.dat)
# listing(wells(plate = "CUSTOM:GROWTH-DAT"))
@

\subsection{Input of TECAN data}\label{tecan-input}

%TODO Lea: explain the instrument where the file comes from. "TECAN" is the corporation, not the instrument...

Here we will use an exemplar that comes with \pkg{opm} as input data file:

<<label=input-tecan>>=
tecan.file <- opm_files("growth")
tecan.file <- grep("tecan", tecan.file, ignore.case = TRUE, value = TRUE)
tecan <- read.table(tecan.file)
head(tecan)
@

%TODO Lea: explain how one gets such a file

This format is not particularly useful within \proglang{R} but can be converted using the ``rectangular'' mode of \code{opmx}.

%TODO Lea: convert the data frame and explain what is going on

<<label=opmx-rectangular>>=
# rectangular input, as it comes from the 'tecan' object
(y <- opmx(tecan, "rectangular", plate.type = "growth", position = 1,
    interval = 1))
@

\rcsmark{TODO.}

\section{Visualisation of growth curves}\label{visualisation}

visualisation of potato data

\begin{figure}
\centering
<<label=potato-growth,fig=TRUE,echo=FALSE,width=10,height=8>>=
xy_plot(potato.fm, theor.max = FALSE, main = "potato growth", rcr = 1,
  include = "Genotype")
@
\caption{
\label{fig:potato_xy_plot}
here some caption about the plot
}
\end{figure}

here some description

\begin{figure}
\centering
<<label=xy-plot-coli,fig=TRUE,echo=FALSE,width=10,height=8>>=
xy_plot(y, theor.max = FALSE, main = "E. coli growth on Glucose")
@
\caption{
\label{fig:growth_xy_plot}
here some caption about the plot
}
\end{figure}

%
%\begin{figure}
%\centering
%<<label=xy-plot-coli-split,fig=TRUE,echo=FALSE,width=10,height=8>>=
%xy_plot(yy, theor.max = FALSE, main = "E. coli growth on Glucose")
%@
%\caption{
%\label{fig:_xy_plot}
%here some caption about the plot
%}
%\end{figure}
\rcsmark{TODO.}

<<label=plot-potato>>=
print(xy_plot(potato.fm, theor.max = FALSE, include = "Genotype",
  main = list(in.parens = FALSE), neg.ctrl = FALSE, ylab = "Mass [g]"))
print(xy_plot(potato.dm, theor.max = FALSE, include = "Genotype",
  main = list(in.parens = FALSE), neg.ctrl = FALSE, ylab = "Mass [g]"))
@

%TODO Lea: finish this and do the same for the TECAN data, make subsections where suitable
%TODO Lea: check whether plotting functions must be modified to accomodate these data


\section{Estimating parameters from growth curves}\label{estimation}


\rcsmark{TODO.}

%TODO Lea: check carefully which spline method is the best here, make subsections where suitable


\section{Statistical analysis of growth curves}\label{statistics}


\rcsmark{TODO.}

%TODO Lea: conduct selected analyses that make sense for these data, make subsections where suitable


\section{Acknowledgements}
We are grateful to Victoria Michael (\ac{DSMZ}) for providing growth curves measured with a TECAN instrument.

%\clearpage

\bibliography{opm}

\end{document}