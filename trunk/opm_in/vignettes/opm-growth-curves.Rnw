

\documentclass[nojss]{jss}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% GENERAL HINTS: STYLE OF THIS DOCUMENT
%
% See the according section in the Rnw file for the main tutorial!!!
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% These commands do nothing. They are used for a logical annotation of text,
% causing the spellchecker to ignore its content.
%
\def\Surname{}
\def\German{}

% Acronyms
%
\usepackage{acronym}
\acrodef{CSV}{Comma-Separated Values}
\acrodef{DM}{Dry Mass}
\acrodef{DSM}{\German{Deutsche Sammlung von Mikroorganismen}}
\acrodef{DSMZ}{\German{Deutsche Sammlung von Mikroorganismen und Zellkulturen}}
\acrodef{FM}{Fresh Mass}
\acrodef{PM}{Phenotype Microarray}

%% Add Revision Control System (RCS) Markups
\usepackage{ulem}      % use this for sout
\usepackage{hyperref}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{enumitem}
%\usepackage{fancyvrb}
\normalem              % set \emph to \textit again
% Additions (in blue)
\def\rcsadd#1{{\color{blue}#1}}
% Deletions (in red)
\def\rcsdel#1{{\color{red}\sout{#1}}}
% Yellow box (few words)
\def\rcsmark#1{\colorbox{yellow}{#1}}
%Yellow box (paragraph)
\def\rcscom#1{\noindent\newline\vspace*{0.5cm}\colorbox{yellow}{\parbox{\textwidth}{#1}}\vspace*{0.5cm}}


%% overwrite JSS definition of subsubsections
%% e.g., use numbering
\renewcommand{\jsssubsubsec}[2][default]{\vskip \preSskip%
  \pdfbookmark[3]{#1}{Subsubsection.\thesubsubsection.#1}%
  \refstepcounter{subsubsection}%
  {\large \thesubsubsection. #2} \nopagebreak
  \vskip \postSskip \nopagebreak}

%% overwrite JSS definitions of code sections
%% (make font smaller)
\DefineVerbatimEnvironment{Sinput}{Verbatim}{fontshape=sl, fontsize=\small}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{Scode}{Verbatim}{fontshape=sl, fontsize=\small}

\DefineVerbatimEnvironment{Code}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{CodeInput}{Verbatim}{fontshape=sl, fontsize=\small}
\DefineVerbatimEnvironment{CodeOutput}{Verbatim}{fontsize=\small}



%% needed for CRAN checking
%\VignetteIndexEntry{Growth curves in opm}


% authors, first page
\author{Lea A.I. \Surname{Vaas}\\Leibniz Institute \acs{DSMZ} \And
        Markus \Surname{G\"{o}ker}\\Leibniz Institute \acs{DSMZ}}


% title, first page
\title{Analysing growth curves and other user-defined data in \pkg{opm}}


% authors, header on every 2nd page
\Plainauthor{L.A.I. Vaas, M. G\"{o}ker}


% main title, first page
\Plaintitle{Analysing growth curves and other user-defined data in opm}


% short title, header on every 2nd page
\Shorttitle{User-defined plates in \pkg{opm} (\today)}


%% BEGIN FROZEN SECTION

\Abstract{
This is tutorial about the analysis of growth curves and other user defined kinetics with the \pkg{opm} package in the version of \today{}.
It is explained how any kinds of growth or respiration measurements can be input into \pkg{opm}.
Data without a real structuring into plates and wells can nevertheless be studied with \pkg{opm} by using a \textit{virtual} arrangement into plates and wells.
This convention is not an oddity but rather the appropriate means to enable the visual and statistical comparisons of interest and to disable those that make no sense for the data.
We also show how \ac{PM} data with user-defined plate types can be analysed.
Analysing such data visually and statistically requires in some cases adaptations of function arguments whose defaults are targeting \ac{PM} data.
All these practically relevant issues are explained in detail.
}

\Keywords{Growth Kinetics}

\Plainkeywords{respiration kinetics, pathways, CAS, MeSH, ChEBI, MetaCyc, KEGG, pathview}

\Address{
  Markus \Surname{G\"{o}ker}\\
  Leibniz Institute \acs{DSMZ} -- German Collection of Microorganisms and Cell Cultures\\
  \German{Braunschweig}\\
  \\
  Telephone: +49/531-2616-272\\
  Fax: +49/531-2616-237\\
  E-mail: \email{markus.goeker@dsmz.de}\\
  URL: \url{www.dsmz.de}\\
}


%% this must be included if Sweave is used (with % symbols):
%% need no \usepackage{Sweave.sty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}
% NOTE: Rstudio might insert a line '\SweaveOpts{concordance=TRUE}' after '\begin{document}', which is removed again by the build script, as it causes warning messages during R CMD check.
% So please don't try to rescue that line, and don't rely on it being there.


%% so far adding a TOC proved unsuccessful -- apparently the JSS style doesn't allow for a TOC
%\tableofcontents
%\newpage
\acresetall

\section{Introduction}\label{introduction}

A detailed description of the OmniLog\textregistered \ \ac{PM} system, its measuring procedure and data characteristics are found in the vignette ``\pkg{opm}: An R Package for Analysing Phenotype Microarray and Growth Curve Data'' (called ``main tutorial'' in the following).
How substrate information stored within \pkg{opm} can be accessed and used for advanced visual and statistical analyses is explained in the vignette ``Working with substrate information in \pkg{opm}'' (called ``substrate tutorial'' in the following).
The description of the methods below do not presuppose that the user is already familiar with the usage of \pkg{opm}.
But for details on its approaches to visualisation and statistical analysis we will refer to the main tutorial, the substrate tutorial as well as the entries of the \pkg{opm} manual.
Especially the concepts behind the different classes of \pkg{opm} objects are only explained in the main tutorial, and the methods available for these classes are only explained in the main and substrate tutorial.

In addition to visual inspection or statistical comparative analyses of \ac{PM} data, as described in the main tutorial and the substrate tutorial, users might be interested in analysing data other than \ac{PM} data, or analysing \ac{PM} with user-defined plate types.
To work with user-defined \ac{PM} plates only requires registering these plates, i.e. storing a mapping from well coordinates to substrate names, and optionally also a full, descriptive name for the plate.
The analysis of data other than \ac{PM} data, such as growth curves, additionally requires inputting these data and converting them to \proglang{OPMX} objects.
If these data are not really structured into plates and wells, a \textit{virtual} arrangement into plates and wells must be established, as well as a virtual positioning of the plates in a reader, which is used for identifying each plate.
This nomenclature may be unusual for data that have not been measured in plate readers, but presents no problems in practice.
Users should be aware, however, which kinds of comparisons can be made within and between plates of the same plate type.
Indeed, the arrangement into virtual plates and wells is the appropriate means to ensure that the visual and statistical comparisons of interest for the data are possible and that those that make no sense are disabled.
Note that some defaults of the plotting functions are only suitable for \ac{PM} data.
Hence, the functions should be called slightly distinctly.

Besides these slight restrictions, which are illustrated with examples below, non-\ac{PM} data can be analysed with \pkg{opm} almost like \ac{PM} data.


\section{Preparation}\label{preparation}

<<label=chunk-setup, echo=FALSE>>=
options(width = 90)
options(prompt = "R> ")
options(continue = "   ")
options(useFancyQuotes = FALSE)
library("methods")
@

As usual, \pkg{opm} must be loaded before any analysis can begin:

<<label=load-library>>=
if ("package:opm" %in% search())
  detach("package:opm", unload = TRUE)
library("opm")
@

\section{Growth-curve data input}\label{data-input}

\subsection{User-entered data frames}\label{user-entered-input-data}

In the following we will use the growth-measurements data set from \citet{ijms140715141} as exemplar.
These data have been entered by hand and then input into \proglang{R} with one of the functions for reading \ac{CSV}, yielding a data frame that comes with \pkg{opm}:

<<label=load-potatoes>>=
data("potato")
head(potato)
@

For details on this data set, enter \code{?potato} at the \proglang{R} prompt.
The measurements are in ``long'' format and must be reshaped using the eponymous function into ``wide'' format.
The ``long'' format was deliberately chosen for demonstrating the use of the \code{reshape} function.
We reshape separately for the \ac{DM} and \ac{FM} measurements within the data set:

<<label=reshape-potatoes>>=
potato.fm <- reshape(potato, v.names = "FM", drop = "DM", direction = "wide",
  idvar = c("Genotype", "Treatment", "Replicate"), timevar = "Time")
potato.dm <- reshape(potato, v.names = "DM", drop = "FM", direction = "wide",
  idvar = c("Genotype", "Treatment", "Replicate"), timevar = "Time")
@

For \code{reshape}, ``long'' format means that each measurement is stored in a separate record with one entry per row (see above).
Thus here for each data point the ``Genotype'', ``Treatment'' and ``Time'' entries have to be repeated, resulting in a data frame with \Sexpr{nrow(potato)} rows in \Sexpr{ncol(potato)} columns.
A call to \code{reshape} can rearrange the data set into a form where the columns ``Genotype'', ``Treatment'' and ``Replicate'' are kept and the columns ``Time'' and either ``\ac{FM}'' or ``\ac{DM}'', respectively, are merged, resulting in \Sexpr{length(grep("^FM[.]", colnames(potato.fm), FALSE, TRUE))} columns representing the measurement times:

<<label=potato-reshaped>>=
head(potato.fm)
@

Thus the dimensions of the data dwindled to \Sexpr{nrow(potato.fm)} rows in \Sexpr{ncol(potato.fm)} columns.
Now the data are in the right arrangement for the next step, the conversion into \proglang{OPMX} or \proglang{MOPMX} objects.
(When entering data manually, users who directly choose the ``wide'' format can, of course, skip the conversion with \code{reshape}.)

The main function for converting user-defined data frames to \proglang{OPMX} or \proglang{MOPMX} objects is \code{opmx}, which can directly be applied to the objects created in the last step.
This works because the ``horizontal'' input format of \code{opmx} corresponds to the ``wide'' format of \code{reshape}.

<<label=potatoes-to-opmx>>=
potato.fm <- opmx(potato.fm, position = c("Genotype", "Replicate"),
  well = "Treatment", prefix = "FM.",
  full.name = c(fm = "Growth experiment, fresh mass"))
potato.dm <- opmx(potato.dm, position = c("Genotype", "Replicate"),
  well = "Treatment", prefix = "DM.",
  full.name = c(dm = "Growth experiment, dry mass"))
@

The data frames passed to \code{opmx} contain all substrate information in their ``Treatment'' column.
Its content will be interpreted as substrate names for wells, which are virtual in our case.
Hence, \pkg{opm} registers the mapping from well coordinates to substrate names on the fly.
The substrate names are taken directly from the data frame in ``horizontal'' format and registered after sorting.
The plate type must be provided, however.
As it is not within the data frame, the short name of the plate type is taken from the \code{full.name} argument, whose main purpose is to enter the full, descriptive name of the plate type.
That is, a virtual plate with virtual wells, yielding a user-defined plate type, will be registered.
The \code{prefix} argument helps identifying the columns with measurements over time.

``Genotype'' and ``Replicate'' go to the metadata of the resulting object and together identify each plate.
In the case of \ac{PM} data, this is done using the position of the plate within the OmniLog\textregistered \ reader.
Thus the relevant argument here is \code{position}, which must be supplied unless there is a column of that name.
If so, its content is used literally, otherwise it is newly constructed from the columns explicitly given in the \code{position} argument, yielding a grouping of plates equivalent to the combination of factor levels in these columns.
So the ``plate position'' is usually also virtual, but just acts as an identifier of the plate.

The registered plate type can be queried as follows:

<<label=show-potato-plate-type>>=
plate_type(TRUE) # shows all existing user-defined plates
listing(wells(plate = c("CUSTOM:FM", "CUSTOM:DM")))
@

Note the prefix ``CUSTOM:'', which is used to distinguish user-defined plate types from those that come with \pkg{opm}.
The object resulting from \code{listing} can be output with \code{to_yaml} or \code{saveRDS} for externally storing plate types in files.
Indeed, please keep in mind that the definition of plate types is only available in the current \proglang{R} session.
The definitions will be lost once the session is terminated.

%% END FROZEN SECTION

%Saving and/or loading of a session can be managed by the functionality provided by \pkg{session} \citep{warnes2012}.
%TODO Lea: It is a good idea that you searched for and found this package. But whether this approach really would rescue the user-entered plate types must be carefully tested. Otherwise it should not be recommended here.

%% BEGIN FROZEN SECTION

With the resulting \code{potato.dm} and \code{potato.fm} objects the user can now follow the \pkg{opm} work flow for processing \ac{PM} data.
Please continue in Section~\ref{visualisation} and the following sections for plotting and statistical analysis of the estimated curve parameters.

It is possible to first register the plate, as shown in Section~\ref{register-plate-type}, and then convert the data \textit{via} \code{opmx}.
This makes most sense if another ordering of wells should be enforced.
Otherwise \code{opmx} takes the substrate names directly from the data frame in ``horizontal'' format and registers them after sorting.

\subsection{Direct registration of plate types}\label{register-plate-type}

An example input file comes with \pkg{opm} containing growth-curve data derived from an experiment with two \textit{Escherichia coli} strains (\ac{DSM} 18039 $=$ K12 and the type strain \ac{DSM} 30083\textsuperscript{T}) on increasing Glucose concentrations.
Here we are dealing with a real plate with real wells, but the registering procedure would be the same for virtual plates with virtual wells.
Thus, it will here be shown how to prepare a plate map and register it as a new plate type.
Section~\ref{register-plate-type} then shows how to import the data and subsequently convert them to an \proglang{OPMX} or \proglang{MOPMX} object.
Each combination of strain and Glucose concentration was repeated twice on the plate.
It will thus be shown how to define a numbering of these repetitions suitable for later on using the \code{split} function to split the object into one object per repetition.

The \pkg{opm} package offers several ways to set up a user-defined plate layout.
The function \code{register_plate} is useful for both customised \ac{PM} plates and measurements from quite different experiments such as growth curves and other kinds of kinetics.

For small data sets it might be feasible to type the substrate allocation manually into a character vector, as done in the following.
The short name of the plate type will be ``growth'', as simply given by the named function argument.
Here two argument of the same name are passed to the function for registering the full name and the well mapping in a single call:

<<label=register_plate, results=hide>>=
register_plate(
  growth = c(
    A01 = "Negative Control #1", A02 = "10mM Glucose #1",
    A03 = "20mM Glucose #1", A04 = "50mM Glucose #1",
    A05 = "100mM Glucose #1", A06 = "200mM Glucose #1",
    B01 = "Negative Control #2", B02 = "10mM Glucose #2",
    B03 = "20mM Glucose #2", B04 = "50mM Glucose #2",
    B05 = "100mM Glucose #2", B06 = "200mM Glucose #2",
    C01 = "Negative Control #3", C02 = "10mM Glucose #3",
    C03 = "20mM Glucose #3", C04 = "50mM Glucose #3",
    C05 = "100mM Glucose #3", C06 = "200mM Glucose #3",
    D01 = "Negative Control #4", D02 = "10mM Glucose #4",
    D03 = "20mM Glucose #4", D04 = "50mM Glucose #4",
    D05 = "100mM Glucose #4", D06 = "200mM Glucose #4"
  ),
  growth = "Growth on Glucose"
)
listing(wells(plate = "custom:growth"))
@

However, manually entering the well mapping is error prone and not efficient when dealing with data sets containing more than a few wells.
Alternatively, a user-designed plate can also be registered with a plate map given as matrix.
The matrix then directly represents the allocation of the used substrates on the plate.
Because of the repetitions in the substrate names (note the numbering, which is necessary here to generate unique substrate names, and later on important to split the plate), the texts can also be generated with fewer code:

<<label=register-plate-via-matrix, results=hide>>=
# create constant part of the substrate names
growth <- c("Negative Control", "10mM Glucose", "20mM Glucose",
  "50mM Glucose", "100mM Glucose", "200mM Glucose")
# create repetitions and assign according numbers
growth <- paste(rep(growth, each = 4), rep(1:4, 4), sep = " #")
# create matrix that mirrors the plate layout
growth <- matrix(growth, nrow = 4, ncol = 6,
  dimnames = list(LETTERS[1:4], 1:6))
# register this plate type and show the result
register_plate(growth = growth, growth = "Growth on Glucose")
listing(wells(plate = "custom:growth"))
@

Plates with other layouts can be put together in the same way but using other more or fewer row and/or column names.
Plates with other repetition structure, or no repetitions of substrates at all, can be put together in the same way, too, but modifying or omitting the way a substrate numbering is introduced.
Instead of a matrix, a data frame could be used as well.
We will try this here after showing how to delete a plate type again by providing a \code{NULL} argument:

<<label=register-plate-via-data-frame, results=hide>>=
register_plate(growth = NULL)
growth <- as.data.frame(growth)
register_plate(growth = growth, growth = "Growth on Glucose")
listing(wells(plate = "CUSTOM:GROWTH"))
@


\subsection{Input of TECAN data}\label{tecan-input}

The data for which we have registered a full plate name and a mapping from well coordinates to substrate names in Section~\ref{register-plate-type} are contained in an exemplar input file that comes with \pkg{opm}.
It can be found, and input into \proglang{R}, as follows:

<<label=input-tecan>>=
tecan.file <- opm_files("growth")
tecan.file <- grep("tecan", tecan.file, ignore.case = TRUE, value = TRUE)
tecan <- read.table(tecan.file)
head(tecan)
@

%% END FROZEN SECTION

This file was output by an Infinite\textregistered \ F200 PRO instrument as distributed by the TECAN corporation.
After data recording, the Magellan\textsuperscript{TM} software generates such as file \textit{via} the ``save as excel'' or the ``save as \code{.asc}'' option in the ``edit'' menu.

The resulting format is not particularly useful within \proglang{R} but can be converted using the ``rectangular'' mode of \code{opmx}:

<<label=opmx-rectangular>>=
tecan <- opmx(tecan, "rectangular", plate.type = "growth", position = "1A",
  interval = 1)
tecan
@

Note that we have to refer to the previously registered plate type, ``growth''.
If several plates of this plate type are to be dealt with, the \code{position} argument is important for identifying each plate.
The format of the \code{position} entry can, in principle, be arbitrarily selected by the user, but the shown format is the recommended one, i.e. an integer followed by a single letter.
The optional \code{interval} argument provides the time interval between two consecutive measurements.
In the given example one measurement per hour was recorded, thus the default fits perfectly when assigning increasing integers starting at 0.
If \code{interval} is stated explicitly, ideally, it is provided in hours.
Time series with irregular intervals can be entered with the same argument (by directly providing each time point).
Please, see also the manual for further details on the usage of this argument.

The generated \proglang{OPM} object can now be split according to the repetition structure of the wells, and metadata can be added that describe each resulting plate:

\rcscom{[Lea, please enter the correct strain designations in the code snippet for assigning metadata.]}

<<label=split-tecan>>=
tecan <- split(tecan)
metadata(tecan) <- data.frame(Replicate = c(1, 2, 1, 2),
  Strain = rep(c("Strain 1", "Strain 2"), each = 2),
  stringsAsFactors = FALSE)
dim(tecan)
@


\section{Visualisation of growth curves}\label{visualisation}

Visualising raw measurements of growth curves with the methods intended for \ac{PM} data is straightforward, but some adaptations are necessary due to the deviations between the distinct kinds of data.
For instance, the expected maximum for \ac{PM} data can seldom be used for delimiting the y axes, and the data are not measured in OmniLog\textregistered \ units, and a negative control might not be present:

<<label=potato-growth-dummy, eval=FALSE>>=
xy_plot(potato.fm, theor.max = FALSE, rcr = 1, include = "Genotype",
  main = list(in.parens = FALSE), ylab = "Fresh cell mass [mg]", 
  neg.ctrl = FALSE)
@

\begin{figure}
\centering
<<label=potato-growth-figure, fig=TRUE, echo=FALSE, width=10, height=8>>=
xy_plot(potato.fm, theor.max = FALSE, rcr = 1, 
  include = "Genotype", main = list(in.parens = FALSE), 
  ylab = "Fresh cell mass [mg]", neg.ctrl = FALSE)
@
\caption{
\label{fig:potato_xy_plot}
Potato cell line growth measurements, recorded as fresh mass, visualised using the \code{xy\_plot} method.
See the main tutorial for details on this kind of plotting.
The plot indicates that the wild type grows better than the genetically modified cell lines under non-stress (control) conditions.
It also indicates that the stresses impair growth but that the genetically modified cells grow better then the wild type under moderate stress conditions.
}
\end{figure}

The result is shown in Figure~\ref{fig:potato_xy_plot}.
The TECAN data (which contain a negative control) can be visualised in the same way as the potato data, yielding Figure~\ref{fig:growth_xy_plot}.
Note the \code{rm.num} argument, which causes the removal of the numbering from the end of the full well names (which is not needed any more after applying the \code{split} function as described in Section~\ref{tecan-input}):
%\rcsmark{[Lea, please enter an appropriate y-axis description for the E. coli plot.]}

<<label=xy-plot-coli-dummy, eval=FALSE, echo=TRUE>>=
xy_plot(tecan, theor.max = FALSE, include = "Strain",
  main = list(in.parens = FALSE), ylab = "OD at 590nm", rm.num = TRUE)
@

\begin{figure}
\centering
<<label=xy-plot-coli-figure, fig=TRUE, echo=FALSE, width=10, height=8>>=
xy_plot(tecan, theor.max = FALSE, include = "Strain",
  main = list(in.parens = FALSE), ylab = "OD at 590nm", rm.num = TRUE)
@
\caption{
\label{fig:growth_xy_plot}
Growth of two \textit{E. coli} strains on Glucose, visualised using the \code{xy\_plot} method.
See the main tutorial for details on this kind of plotting.
The plot indicates that one of the strains outgrows the other unless high concentrations of Glucose are applied.
}
\end{figure}


\section{Estimating parameters from growth curves}\label{estimation}


\rcscom{
TODO: Lea, please make recommendations regarding the spline method to be used with these data.
For issues not specific to growth data refer to the main tutorial.
}


\section{Statistical analysis of growth curves}\label{statistics}


\rcscom{
TODO: Lea, please conduct selected analyses that make sense for these data.
For instance, the interpretations given in the figure captions should be assessed using \code{opm\_mcp}.
For issues not specific to growth data refer to the main tutorial.
}


\section{Acknowledgements}
We are grateful to Victoria Michael (\ac{DSMZ}) for providing growth curves measured with a TECAN instrument.


\bibliography{opm}

\end{document}
